# [104] 商品查询接口技术实现文档

## 文档信息

| 文档编号 | [104] |
|----------|-------|
| 文档名称 | 商品查询接口技术实现文档 |
| 版本号 | 1.0 |
| 创建日期 | 2026-01-07 |
| 作者 | 技术架构师 |
| 项目名称 | 大数据商城后端系统 |

## 目录

1. [概述](#概述)
2. [接口设计](#接口设计)
3. [数据模型设计](#数据模型设计)
4. [存储架构设计](#存储架构设计)
5. [缓存策略](#缓存策略)
6. [实现方案](#实现方案)
7. [错误处理](#错误处理)
8. [性能优化](#性能优化)
9. [测试方案](#测试方案)
10. [部署配置](#部署配置)

## 概述

### 项目背景

本接口是大数据库商城后端系统商品管理模块的核心查询功能，主要用于商品列表展示和商品详情查看。该接口基于HBase和Redis的大数据技术栈，实现高性能的商品数据查询服务。

### 设计目标

1. **高性能查询**：充分利用HBase和Redis缓存实现快速数据查询
2. **分页查询**：支持大量商品数据的分页查询和排序
3. **缓存优化**：通过多级缓存提升查询性能
4. **数据完整性**：确保查询结果的准确性和完整性
5. **扩展性**：支持复杂查询条件和排序需求

### 技术栈

- **后端框架**：Spring Boot 2.x
- **大数据存储**：HBase 2.x
- **缓存系统**：Redis 6.x
- **数据序列化**：Jackson
- **连接客户端**：HBase Java API, Jedis

## 接口设计

### 接口规范

#### 1. 获取商品列表接口

**接口路径**：`GET /api/dev/product/list`

**接口说明**：分页查询商品列表，支持按分类、品牌等条件筛选

**请求参数**：

| 参数名 | 类型 | 必填 | 默认值 | 说明 |
|--------|------|------|--------|------|
| page | integer | 否 | 1 | 页码，从1开始 |
| size | integer | 否 | 20 | 每页大小，最大100 |
| category | string | 否 |  | 商品分类ID |
| brand | string | 否 |  | 品牌名称 |
| status | string | 否 | ACTIVE | 商品状态 |
| sortBy | string | 否 | create_time | 排序字段 |
| sortOrder | string | 否 | desc | 排序方向(asc/desc) |

**响应格式**：
```json
{
  "code": 200,
  "message": "查询成功",
  "timestamp": "2026-01-07T10:30:00Z",
  "data": {
    "total": 100,
    "page": 1,
    "size": 20,
    "totalPages": 5,
    "hasNext": true,
    "hasPrevious": false,
    "products": [
      {
        "id": "00010001",
        "name": "华为Mate60 Pro",
        "category": "0001",
        "brand": "华为",
        "price": 6999.00,
        "status": "ACTIVE",
        "createTime": "2026-01-07T10:30:00Z",
        "image": {
          "id": "hdfs://bigdata01:9000/product_images/0001/00010001/1704625800000_main.jpg",
          "type": "main",
          "filename": "huawei_mate60_main.jpg",
          "size": 245760,
          "uploadTime": "2026-01-07T10:30:00Z"
        }
      }
    ]
  }
}
```

#### 2. 查看商品详情接口

**接口路径**：`GET /api/dev/product/{productId}`

**接口说明**：根据商品ID查询完整的商品详细信息

**请求参数**：

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| productId | string | 是 | 商品ID |

**响应格式**：
```json
{
  "code": 200,
  "message": "查询成功",
  "timestamp": "2026-01-07T10:30:00Z",
  "data": {
    "id": "00010001",
    "name": "华为Mate60 Pro",
    "category": "0001",
    "brand": "华为",
    "price": 6999.00,
    "cost": 5500.00,
    "description": "华为旗舰智能手机，HarmonyOS 4.0",
    "spec": {
      "screen": "6.82英寸",
      "processor": "麒麟9000S",
      "memory": "12GB+512GB",
      "camera": "5000万像素"
    },
    "tags": ["旗舰机", "鸿蒙系统", "5G"],
    "status": "ACTIVE",
    "createTime": "2026-01-07T10:30:00Z",
    "updateTime": "2026-01-07T10:30:00Z",
    "image": {
      "id": "hdfs://bigdata01:9000/product_images/0001/00010001/1704625800000_main.jpg",
      "type": "main",
      "filename": "huawei_mate60_main.jpg",
      "size": 245760,
      "uploadTime": "2026-01-07T10:30:00Z"
    },
    "stock": {
      "total": 1000,
      "safe": 100,
      "lock": 0,
      "warehouse": "BJ001"
    },
    "statistics": {
      "viewCount": 0,
      "saleCount": 0,
      "collectCount": 0
    }
  }
}
```

## 数据模型设计

### 查询请求DTO

#### ProductQueryRequest
```java
public class ProductQueryRequest {
    private Integer page = 1;
    private Integer size = 20;
    private String category;
    private String brand;
    private String status = "ACTIVE";
    private String sortBy = "create_time";
    private String sortOrder = "desc";

    // Getters and Setters
}
```

#### ProductListResponse
```java
public class ProductListResponse {
    private long total;
    private int page;
    private int size;
    private int totalPages;
    private boolean hasNext;
    private boolean hasPrevious;
    private List<ProductSummary> products;

    // Getters and Setters
}
```

#### ProductSummary
```java
public class ProductSummary {
    private String id;
    private String name;
    private String category;
    private String brand;
    private BigDecimal price;
    private String status;
    private LocalDateTime createTime;
    private ProductImage image;

    // Getters and Setters
}
```

#### ProductDetailResponse
```java
public class ProductDetailResponse {
    private String id;
    private String name;
    private String category;
    private String brand;
    private BigDecimal price;
    private BigDecimal cost;
    private String description;
    private Map<String, Object> spec;
    private List<String> tags;
    private String status;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    private ProductImage image;
    private ProductStock stock;
    private ProductStatistics statistics;

    // Getters and Setters
}
```

## 存储架构设计

### HBase表结构

#### 商品信息表 (product_info)

**RowKey设计**：{category_id}_{product_id}_{timestamp}
- category_id：分类ID（4位）
- product_id：商品ID（8位）
- timestamp：时间戳（13位）

**列族结构**：
```
product_info
├── cf_base (商品基本信息)
│   ├── name: 商品名称
│   ├── category: 品类编号
│   ├── brand: 品牌
│   ├── price: 价格
│   ├── cost: 成本价
│   ├── status: 状态
│   └── create_time: 创建时间
├── cf_detail (商品详细信息)
│   ├── description: 描述
│   ├── spec: 规格参数
│   ├── image: 图片信息JSON对象（包含HDFS路径、类型、大小等元数据）
│   └── tags: 标签
├── cf_stock (库存信息)
│   ├── total_stock: 总库存
│   ├── warehouse_stock: 仓库库存
│   ├── safe_stock: 安全库存
│   └── lock_stock: 锁定库存
└── cf_stat (统计信息)
    ├── view_count: 浏览数
    ├── sale_count: 销量
    ├── collect_count: 收藏数
    └── update_time: 更新时间
```

### HBase查询设计

#### 1. 商品列表查询
- **Scan操作**：全表扫描，结合过滤器实现条件查询
- **分页实现**：使用HBase的PageFilter和RowKey范围限定
- **排序实现**：通过RowKey设计实现排序

#### 2. 商品详情查询
- **Get操作**：根据RowKey精确查询
- **多列族查询**：一次性获取所有相关信息

## 缓存策略

### Redis缓存设计

#### 商品列表缓存
```redis
# 商品列表缓存 (String)
product:list:{category}:{brand}:{status}:{page}:{size}:{sortBy}:{sortOrder} → JSON字符串(包含商品摘要列表和分页信息)
# 过期时间: 300秒(5分钟)
```

#### 商品详情缓存
```redis
# 商品详情缓存 (Hash)
product:detail:{productId} → {
  name: 商品名称,
  category: 品类编号,
  brand: 品牌,
  price: 价格,
  # ... 其他字段
}
# 过期时间: 600秒(10分钟)
```

#### 缓存更新策略
- **读取策略**：Cache Aside模式，先读缓存，缓存未命中再读数据库
- **更新策略**：商品创建/修改时清除相关缓存
- **过期策略**：自动过期，避免数据不一致

## 实现方案

### 核心服务类设计

#### ProductQueryService
```java
@Service
public class ProductQueryService {

    @Autowired
    private ProductHBaseService productHBaseService;

    @Autowired
    private RedisService redisService;

    /**
     * 分页查询商品列表
     */
    public ProductListResponse getProductList(ProductQueryRequest request) {
        // 1. 构建缓存Key
        String cacheKey = buildListCacheKey(request);

        // 2. 尝试从缓存获取
        ProductListResponse cached = redisService.getCachedProductList(cacheKey);
        if (cached != null) {
            return cached;
        }

        // 3. 从HBase查询
        ProductListResponse response = productHBaseService.queryProductList(request);

        // 4. 写入缓存
        redisService.cacheProductList(cacheKey, response, 300);

        return response;
    }

    /**
     * 查询商品详情
     */
    public ProductDetailResponse getProductDetail(String productId) {
        // 1. 构建缓存Key
        String cacheKey = buildDetailCacheKey(productId);

        // 2. 尝试从缓存获取
        ProductDetailResponse cached = redisService.getCachedProductDetail(cacheKey);
        if (cached != null) {
            return cached;
        }

        // 3. 从HBase查询
        ProductDetailResponse response = productHBaseService.queryProductDetail(productId);

        // 4. 写入缓存
        redisService.cacheProductDetail(cacheKey, response, 600);

        return response;
    }
}
```

#### ProductHBaseService 查询方法
```java
@Service
public class ProductHBaseService {

    /**
     * 分页查询商品列表
     */
    public ProductListResponse queryProductList(ProductQueryRequest request) {
        try (Table table = connection.getTable(TableName.valueOf("product_info"))) {
            Scan scan = new Scan();

            // 设置过滤器
            List<Filter> filters = buildQueryFilters(request);
            if (!filters.isEmpty()) {
                FilterList filterList = new FilterList(FilterList.Operator.MUST_PASS_ALL, filters);
                scan.setFilter(filterList);
            }

            // 设置分页
            PageFilter pageFilter = new PageFilter(request.getSize());
            scan.setFilter(pageFilter);

            // 设置起始RowKey
            if (request.getPage() > 1) {
                String startRowKey = buildStartRowKey(request);
                scan.withStartRow(Bytes.toBytes(startRowKey));
            }

            // 执行查询
            ResultScanner scanner = table.getScanner(scan);
            List<ProductSummary> products = new ArrayList<>();

            for (Result result : scanner) {
                ProductSummary product = parseProductSummary(result);
                products.add(product);
            }

            // 计算总数
            long total = getTotalCount(request);

            return buildPagedResponse(products, total, request);
        }
    }

    /**
     * 查询商品详情
     */
    public ProductDetailResponse queryProductDetail(String productId) {
        try (Table table = connection.getTable(TableName.valueOf("product_info"))) {
            // 构建可能的RowKey模式
            List<String> possibleRowKeys = generatePossibleRowKeys(productId);

            for (String rowKey : possibleRowKeys) {
                Get get = new Get(Bytes.toBytes(rowKey));
                Result result = table.get(get);

                if (!result.isEmpty()) {
                    return parseProductDetail(result);
                }
            }

            throw new RuntimeException("商品不存在: " + productId);
        }
    }
}
```

### 控制器实现

#### ProductController
```java
@RestController
@RequestMapping("/api/dev/product")
@Profile("dev")
@Api(tags = "商品管理")
public class ProductController {

    @Autowired
    private ProductQueryService productQueryService;

    /**
     * 获取商品列表
     */
    @GetMapping("/list")
    @ApiOperation(value = "获取商品列表", notes = "分页查询商品列表，支持条件筛选和排序")
    public ResponseEntity<ApiResponse<ProductListResponse>> getProductList(
            @ApiParam(value = "页码", defaultValue = "1") @RequestParam(required = false) Integer page,
            @ApiParam(value = "每页大小", defaultValue = "20") @RequestParam(required = false) Integer size,
            @ApiParam(value = "商品分类") @RequestParam(required = false) String category,
            @ApiParam(value = "品牌") @RequestParam(required = false) String brand,
            @ApiParam(value = "商品状态") @RequestParam(required = false) String status,
            @ApiParam(value = "排序字段") @RequestParam(required = false) String sortBy,
            @ApiParam(value = "排序方向") @RequestParam(required = false) String sortOrder) {

        try {
            ProductQueryRequest request = new ProductQueryRequest();
            request.setPage(page);
            request.setSize(size);
            request.setCategory(category);
            request.setBrand(brand);
            request.setStatus(status);
            request.setSortBy(sortBy);
            request.setSortOrder(sortOrder);

            ProductListResponse response = productQueryService.getProductList(request);

            return ResponseEntity.ok(ApiResponse.success(response, "查询成功"));
        } catch (Exception e) {
            logger.error("Failed to query product list", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error(500, "查询失败: " + e.getMessage()));
        }
    }

    /**
     * 查看商品详情
     */
    @GetMapping("/{productId}")
    @ApiOperation(value = "查看商品详情", notes = "根据商品ID查询完整的商品信息")
    public ResponseEntity<ApiResponse<ProductDetailResponse>> getProductDetail(
            @ApiParam(value = "商品ID", required = true) @PathVariable String productId) {

        try {
            ProductDetailResponse response = productQueryService.getProductDetail(productId);

            return ResponseEntity.ok(ApiResponse.success(response, "查询成功"));
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error(400, e.getMessage()));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(ApiResponse.error(404, e.getMessage()));
        } catch (Exception e) {
            logger.error("Failed to query product detail: {}", productId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error(500, "查询失败: " + e.getMessage()));
        }
    }
}
```

## 错误处理

### 异常类型

#### 查询异常
- **参数错误**：400 Bad Request
  - 页码或每页大小超出限制
  - 商品ID格式错误
  - 排序字段不支持

- **商品不存在**：404 Not Found
  - 查询的商品ID不存在

- **系统错误**：500 Internal Server Error
  - HBase连接异常
  - Redis连接异常
  - 数据解析异常

### 错误响应格式
```json
{
  "code": 404,
  "message": "商品不存在",
  "timestamp": "2026-01-07T10:30:00Z",
  "data": null
}
```

## 性能优化

### 查询优化策略

#### 1. HBase查询优化
- **RowKey设计**：通过RowKey前缀实现高效的范围查询
- **过滤器使用**：使用HBase过滤器减少数据传输
- **列族优化**：合理设计列族减少I/O操作

#### 2. 缓存优化
- **多级缓存**：结合应用层缓存和Redis缓存
- **缓存预热**：热门商品预加载到缓存
- **缓存失效**：合理设置过期时间和更新策略

#### 3. 分页优化
- **深度分页**：避免大页码的性能问题
- **结果缓存**：缓存分页结果减少重复计算

### 性能指标目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 商品列表查询响应时间 | < 200ms | P95响应时间 |
| 商品详情查询响应时间 | < 100ms | P95响应时间 |
| 缓存命中率 | > 80% | Redis缓存命中率 |
| QPS | > 1000 | 每秒查询数 |

## 测试方案

### 单元测试

#### ProductQueryServiceTest
```java
@SpringBootTest
public class ProductQueryServiceTest {

    @Autowired
    private ProductQueryService productQueryService;

    @Test
    public void testGetProductList() {
        // 测试正常查询
        ProductQueryRequest request = new ProductQueryRequest();
        request.setPage(1);
        request.setSize(10);

        ProductListResponse response = productQueryService.getProductList(request);

        assertNotNull(response);
        assertTrue(response.getTotal() >= 0);
        assertNotNull(response.getProducts());
    }

    @Test
    public void testGetProductDetail() {
        // 测试商品详情查询
        String productId = "00010001";
        ProductDetailResponse response = productQueryService.getProductDetail(productId);

        assertNotNull(response);
        assertEquals(productId, response.getId());
        assertNotNull(response.getImage());
    }
}
```

### 集成测试

#### API测试用例

1. **商品列表查询测试**
   ```
   GET /api/dev/product/list?page=1&size=10&category=0001
   预期：返回第1页的10个商品，分类为0001
   ```

2. **商品详情查询测试**
   ```
   GET /api/dev/product/00010001
   预期：返回完整的商品详细信息
   ```

3. **缓存测试**
   - 验证缓存命中和未命中情况
   - 验证缓存过期机制

## 部署配置

### 环境配置

#### application-dev.properties
```properties
# 商品查询相关配置
product.query.max-page-size=100
product.query.default-page-size=20
product.query.cache.expire-seconds=300

# HBase配置
hbase.zookeeper.quorum=192.168.32.200:2181,192.168.32.201:2181,192.168.32.202:2181
hbase.product.table.name=product_info

# Redis配置
redis.host=192.168.32.200
redis.port=6379
redis.password=123456
redis.pool.max-total=20
redis.pool.max-idle=10
redis.pool.min-idle=5
```

### 监控配置

#### 性能监控指标
- 查询响应时间
- 缓存命中率
- HBase查询次数
- Redis连接池使用情况

#### 健康检查
```java
@Component
public class ProductQueryHealthIndicator implements HealthIndicator {

    @Override
    public Health health() {
        try {
            // 检查HBase连接
            // 检查Redis连接
            // 执行简单查询测试

            return Health.up().build();
        } catch (Exception e) {
            return Health.down(e).build();
        }
    }
}
```

---

**文档版本**：1.0
**最后更新**：2026-01-07
**作者**：技术架构师
