# [109] 销售统计分析开发方案文档

## 文档信息

| 文档编号 | [109] |
|----------|-------|
| 文档名称 | 销售统计分析开发方案文档 |
| 版本号 | 1.0 |
| 创建日期 | 2026-01-07 |
| 作者 | 系统架构师 |
| 项目名称 | 大数据商城后端系统 |
| 背景 | 基于现有订单数据存储结构，实现销售统计分析功能 |

## 目录

1. [项目背景](#项目背景)
2. [功能需求分析](#功能需求分析)
3. [技术方案设计](#技术方案设计)
4. [API接口设计](#API接口设计)
5. [数据结构设计](#数据结构设计)
6. [服务层设计](#服务层设计)
7. [控制器层设计](#控制器层设计)
8. [数据统计策略](#数据统计策略)
9. [性能优化策略](#性能优化策略)
10. [测试策略](#测试策略)
11. [实施计划](#实施计划)

## 项目背景

### 当前系统状态

根据现有代码分析，系统已实现：
- **订单管理**：完整的订单创建、状态管理、查询功能
- **HBase存储**：order_history表存储订单数据，包含商品明细和金额信息
- **Redis缓存**：订单状态计数器，支持实时统计订单数量
- **数据结构**：订单包含商品ID、数量、单价、总金额等统计要素

### 需求来源

根据需求分析文档中的销售分析模块要求，需要实现以下统计功能：
1. **总销售额统计**：历史累计销售额（只统计已支付订单）
2. **当日销售额统计**：当天实时销售额（只统计已支付订单）
3. **当日订单交易数量**：当天订单总数（所有状态）
4. **最畅销商品销售数量**：总销量前三商品（基于已支付订单）

### 核心性能要求

**高并发场景下的性能保障**：
1. **Redis优先策略**：所有统计数据必须缓存在Redis中，避免高并发时频繁查询HBase造成数据库压力
2. **准实时更新策略**：采用定时任务每20秒批量刷新Redis缓存，避免每个订单都触发更新导致大量请求
3. **秒级响应**：前台查询统计数据时，直接从Redis读取，实现毫秒级响应，避免并发刷新页面时大量请求打到后台
4. **缓存预热**：系统启动时预加载统计数据到Redis，确保首次访问也能秒出
5. **防击穿机制**：使用分布式锁防止缓存失效时大量请求同时查询HBase
6. **数据更新缓冲**：订单支付时先写入待更新队列（Redis List），定时任务批量消费队列更新统计数据

### 开发目标

基于现有的订单数据存储，实现高性能、低延迟的销售统计分析功能，确保在高并发场景下系统稳定运行。

## 功能需求分析

### 核心功能点

#### 1. 总销售额统计
- **功能描述**：统计系统上线以来所有已完成订单的总销售额
- **数据来源**：Redis缓存（主） + HBase order_history表（备）
- **统计范围**：只统计COMPLETED状态的订单（确认收货才算最终销售额）
- **计算逻辑**：累加所有已完成订单的actual_amount字段
- **实时性要求**：定时任务每20秒批量更新Redis缓存
- **缓存策略**：
  - Redis Key: `statistics:sales:total` (String类型，存储总销售额)
  - Redis Key: `statistics:sales:total:count` (String类型，存储已完成订单数)
  - Redis Key: `statistics:sales:total:update` (String类型，存储最后更新时间戳)
  - 永久缓存，不设置过期时间
  - 订单完成时写入待更新队列：`statistics:update:queue`（List类型）
  - 定时任务每20秒消费队列，批量更新统计数据
- **输出格式**：包含总销售额、已完成订单数、最后更新时间

#### 2. 当日销售额统计
- **功能描述**：统计当天所有已完成订单的销售额总和
- **数据来源**：Redis缓存（唯一数据源）
- **统计范围**：只统计当日COMPLETED状态的订单（确认收货才算最终销售额）
- **计算逻辑**：统计当日所有已完成订单的actual_amount总和
- **实时性要求**：定时任务每20秒批量更新Redis缓存
- **缓存策略**：
  - Redis Key: `statistics:sales:daily:{yyyyMMdd}` (Hash结构)
  - 字段：sales（销售额）、orders（订单数）、lastUpdate（更新时间戳）
  - 每日凌晨0点自动创建新的日期Key
  - 历史日期数据保留30天后自动过期（EXPIRE 2592000秒）
  - 订单完成时写入待更新队列，定时任务批量更新
- **输出格式**：包含当日销售额、订单数量、平均客单价、最后更新时间

#### 3. 当日订单交易数量
- **功能描述**：统计当天所有订单的总数（包含所有状态）
- **数据来源**：Redis订单状态计数器（唯一数据源）
- **统计范围**：当日所有状态的订单（PENDING_PAYMENT、PAID、COMPLETED、CANCELLED）
- **计算逻辑**：使用现有的 `order:count:daily:{yyyyMMdd}` 计数器
- **实时性要求**：订单创建时立即更新计数器
- **缓存策略**：
  - Redis Key: `order:count:daily:{yyyyMMdd}`
  - 订单创建时 INCR 增加
  - 永久保留历史数据（用于数据分析）
- **输出格式**：包含订单数量、各状态订单数、统计时间

#### 4. 最畅销商品销售数量（总榜前三）
- **功能描述**：统计销量最高的前三款商品
- **数据来源**：Redis Sorted Set（唯一数据源）
- **统计范围**：只统计已完成订单中的商品销量（确认收货才算最终销量）
- **计算逻辑**：统计各商品在所有已完成订单中的销售数量总和，按销量降序排列
- **实时性要求**：定时任务每20秒批量更新Redis排行榜
- **缓存策略**：
  - Redis Key: `statistics:product:sales:rank` (Sorted Set)
  - Score: 商品总销量
  - Member: 商品ID
  - 订单完成时写入待更新队列，定时任务批量使用 ZINCRBY 更新商品销量
  - 永久缓存，不设置过期时间
  - 商品详情缓存：`statistics:product:sales:{productId}` (Hash)
  - 字段：name（商品名称）、totalSales（总销量）、lastUpdate（更新时间戳）
- **输出格式**：商品ID、商品名称、总销量、排名、最后更新时间

### 业务约束

#### 数据一致性要求
- **订单状态**：销售额只统计COMPLETED状态的订单（确认收货才算最终销售）
- **时间范围**：当日统计基于订单完成时间（completeTime），不是创建时间或支付时间
- **数据准确性**：通过Redis原子操作和定时批量更新确保统计数据准确性
- **数据恢复**：系统启动时从HBase重新计算并初始化Redis缓存
- **幂等性保证**：定时任务更新时使用订单ID去重，防止重复统计

#### 性能要求（关键）
- **响应时间**：统计查询响应时间 < 100ms（直接从Redis读取）
- **数据更新**：订单完成后20秒内批量更新Redis缓存（定时任务）
- **并发处理**：支持1000+并发统计查询，Redis直接响应无需访问HBase
- **缓存命中率**：Redis缓存命中率 > 99.9%
- **防击穿**：使用分布式锁防止缓存失效时大量请求同时查询HBase
- **批量更新**：定时任务每次最多处理1000条待更新记录，防止单次处理时间过长

## 技术方案设计

### 整体架构

```
Controller Layer (SalesStatisticsController)
        ↓
Service Layer (SalesStatisticsService)
        ↓
├── SalesStatisticsHBaseService - HBase销售统计数据查询
├── RedisService - Redis缓存统计数据
├── OrderHBaseService - 订单数据查询
└── SalesStatisticsCacheManager - 统计数据缓存管理
```

### 技术选型

#### 数据存储策略（Redis优先）
- **主存储**：Redis缓存，所有统计数据必须存在Redis中
- **备份存储**：HBase存储订单原始数据，仅用于数据恢复和校验
- **查询策略**：100%从Redis查询，绝不直接查询HBase
- **数据恢复**：仅在Redis数据丢失或系统启动时从HBase重建

#### 统计计算策略（批量异步更新）
- **订单创建时**：立即更新订单数量计数器（同步，使用Redis INCR）
- **订单完成时**：将订单ID写入待更新队列 `statistics:update:queue`（同步，使用Redis LPUSH）
- **定时批量更新**：每20秒执行一次定时任务，从队列中批量取出订单ID（RPOP），查询订单详情，批量更新销售额和商品销量
- **缓存预热**：系统启动时从HBase加载所有统计数据到Redis
- **定时校准**：每日凌晨2点从HBase重新计算校准Redis数据，确保数据准确性
- **去重机制**：使用Redis Set记录已处理的订单ID（`statistics:processed:orders:{yyyyMMdd}`），防止重复统计，每日过期

### 业务流程设计

#### 销售统计数据更新流程
```
订单完成 (COMPLETED)
    ↓
写入待更新队列（同步）
    ↓
LPUSH statistics:update:queue {orderId}
    ↓
定时任务（每20秒执行）
    ↓
批量取出订单ID（RPOP，最多1000条）
    ↓
检查去重Set（SISMEMBER statistics:processed:orders:{yyyyMMdd}）
    ↓
查询订单详情（批量从HBase读取）
    ↓
批量更新Redis统计数据
├── INCRBYFLOAT statistics:sales:total {amount}
├── HINCRBY statistics:sales:daily:{yyyyMMdd} sales {amount}
├── HINCRBY statistics:sales:daily:{yyyyMMdd} orders 1
└── ZINCRBY statistics:product:sales:rank {quantity} {productId}
    ↓
记录已处理订单ID（SADD statistics:processed:orders:{yyyyMMdd}）
```

#### 统计查询流程
```
统计查询请求
    ↓
优先查询Redis缓存
    ↓
缓存存在 → 返回缓存数据
    ↓
缓存不存在 → 查询HBase计算 → 更新缓存 → 返回数据
```

## API接口设计

### 接口路径规划

```
/api/statistics
├── GET /api/statistics/total-sales          # 总销售额统计
├── GET /api/statistics/daily-sales          # 当日销售额统计
├── GET /api/statistics/daily-orders         # 当日订单数量统计
└── GET /api/statistics/top-products         # 最畅销商品排行
```

### 接口详细设计

#### 1. 总销售额统计

**接口路径**：`GET /api/statistics/total-sales`

**请求参数**：无

**响应示例**：
```json
{
  "code": 200,
  "message": "查询成功",
  "timestamp": "2026-01-07T12:00:00Z",
  "data": {
    "totalSales": 99999.99,
    "lastUpdateTime": "2026-01-07T11:59:00Z",
    "completedOrders": 888
  }
}
```

#### 2. 当日销售额统计

**接口路径**：`GET /api/statistics/daily-sales`

**请求参数**：
- date（可选）：统计日期，格式yyyy-MM-dd，默认当天

**响应示例**：
```json
{
  "code": 200,
  "message": "查询成功",
  "timestamp": "2026-01-07T12:00:00Z",
  "data": {
    "date": "2026-01-07",
    "dailySales": 12345.67,
    "orderCount": 123,
    "averageOrderValue": 100.37,
    "lastUpdateTime": "2026-01-07T11:59:30Z"
  }
}
```

#### 3. 当日订单交易数量

**接口路径**：`GET /api/statistics/daily-orders`

**请求参数**：
- date（可选）：统计日期，格式yyyy-MM-dd，默认当天

**响应示例**：
```json
{
  "code": 200,
  "message": "查询成功",
  "timestamp": "2026-01-07T12:00:00Z",
  "data": {
    "date": "2026-01-07",
    "orderCount": 123,
    "lastUpdateTime": "2026-01-07T11:59:30Z"
  }
}
```

#### 4. 最畅销商品销售数量

**接口路径**：`GET /api/statistics/top-products`

**请求参数**：
- limit（可选）：返回数量，默认3

**响应示例**：
```json
{
  "code": 200,
  "message": "查询成功",
  "timestamp": "2026-01-07T12:00:00Z",
  "data": {
    "topProducts": [
      {
        "rank": 1,
        "productId": "000100000001",
        "productName": "华为Mate60 Pro",
        "totalSales": 999,
        "lastUpdateTime": "2026-01-07T11:00:00Z"
      },
      {
        "rank": 2,
        "productId": "000100000002",
        "productName": "iPhone 15 Pro",
        "totalSales": 888,
        "lastUpdateTime": "2026-01-07T11:00:00Z"
      },
      {
        "rank": 3,
        "productId": "000100000003",
        "productName": "小米14 Pro",
        "totalSales": 777,
        "lastUpdateTime": "2026-01-07T11:00:00Z"
      }
    ]
  }
}
```

## 数据结构设计

### Redis数据结构设计

#### 销售统计键设计
```redis
# 总销售额统计
statistics:sales:total → "99999.99" (String)
statistics:sales:total:count → "888" (String，已完成订单数)
statistics:sales:total:update → "1641552000000" (String，最后更新时间戳)

# 当日销售额统计 (Hash)
statistics:sales:daily:20260107 → {sales: "12345.67", orders: "123", lastUpdate: "1641552000000"}
# 过期时间：30天（2592000秒）

# 商品销量排行榜 (Sorted Set)
statistics:product:sales:rank → [
  {score: 999, member: "000100000001"},
  {score: 888, member: "000100000002"},
  {score: 777, member: "000100000003"}
]

# 商品销量详情 (Hash)
statistics:product:sales:000100000001 → {name: "华为Mate60 Pro", totalSales: "999", lastUpdate: "1641552000000"}

# 待更新队列 (List)
statistics:update:queue → ["20260107224348000001", "20260107224646000001", ...]
# 订单完成时LPUSH，定时任务RPOP批量消费

# 已处理订单去重集合 (Set)
statistics:processed:orders:20260107 → {"20260107224348000001", "20260107224646000001", ...}
# 每日过期，防止重复统计
```

### 请求DTO设计

#### SalesStatisticsQueryRequest
```java
public class SalesStatisticsQueryRequest {
    private String date;        // 统计日期 (yyyy-MM-dd)
    private Integer limit = 3;  // 排行榜数量限制

    // getters and setters
}
```

### 响应DTO设计

#### TotalSalesResponse
```java
public class TotalSalesResponse {
    private BigDecimal totalSales;      // 总销售额
    private Integer completedOrders;    // 已完成订单数
    private LocalDateTime lastUpdateTime; // 最后更新时间
}
```

#### DailySalesResponse
```java
public class DailySalesResponse {
    private String date;                    // 统计日期
    private BigDecimal dailySales;          // 当日销售额
    private Integer orderCount;             // 订单数量
    private BigDecimal averageOrderValue;   // 平均客单价
    private LocalDateTime lastUpdateTime;   // 最后更新时间
}
```

#### DailyOrdersResponse
```java
public class DailyOrdersResponse {
    private String date;                    // 统计日期
    private Integer orderCount;             // 订单数量
    private LocalDateTime lastUpdateTime;   // 最后更新时间
}
```

#### TopProductDto
```java
public class TopProductDto {
    private Integer rank;                   // 排名
    private String productId;               // 商品ID
    private String productName;             // 商品名称
    private Integer totalSales;             // 总销量
    private LocalDateTime lastUpdateTime;   // 最后更新时间
}
```

#### TopProductsResponse
```java
public class TopProductsResponse {
    private List<TopProductDto> topProducts; // 畅销商品列表
}
```

## 服务层设计

### SalesStatisticsService 接口设计

```java
public interface SalesStatisticsService {

    /**
     * 获取总销售额统计
     * @return 总销售额统计信息
     */
    TotalSalesResponse getTotalSales();

    /**
     * 获取当日销售额统计
     * @param date 统计日期，null表示当天
     * @return 当日销售额统计信息
     */
    DailySalesResponse getDailySales(String date);

    /**
     * 获取当日订单数量统计
     * @param date 统计日期，null表示当天
     * @return 当日订单数量统计信息
     */
    DailyOrdersResponse getDailyOrders(String date);

    /**
     * 获取最畅销商品排行榜
     * @param limit 返回数量限制
     * @return 畅销商品排行榜
     */
    TopProductsResponse getTopProducts(int limit);

    /**
     * 将订单ID写入待更新队列
     * @param orderId 已完成的订单ID
     */
    void enqueueOrderForStatisticsUpdate(String orderId);
}
```

### SalesStatisticsServiceImpl 实现设计

```java
@Service
public class SalesStatisticsServiceImpl implements SalesStatisticsService {

    @Autowired
    private RedisService redisService;

    @Autowired
    private SalesStatisticsHBaseService hBaseService;

    @Autowired
    private ProductService productService;

    /**
     * 获取总销售额统计
     * 优先从Redis获取，Redis没有则从HBase计算
     */
    @Override
    public TotalSalesResponse getTotalSales() {
        // 1. 尝试从Redis获取
        String totalSalesStr = redisService.getString("statistics:sales:total");
        if (totalSalesStr != null) {
            BigDecimal totalSales = new BigDecimal(totalSalesStr);
            String lastUpdateStr = redisService.getString("statistics:sales:total:update");
            LocalDateTime lastUpdate = lastUpdateStr != null ?
                LocalDateTime.parse(lastUpdateStr) : LocalDateTime.now();

            return new TotalSalesResponse(totalSales, getCompletedOrderCount(), lastUpdate);
        }

        // 2. 从HBase计算并缓存
        TotalSalesResponse response = hBaseService.calculateTotalSales();
        cacheTotalSales(response);
        return response;
    }

    /**
     * 获取当日销售额统计
     */
    @Override
    public DailySalesResponse getDailySales(String date) {
        String dateKey = date != null ? date : LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));

        // 从Redis获取当日统计数据
        Map<String, String> dailyStats = redisService.hgetAll("statistics:sales:daily:" + dateKey);

        if (dailyStats.isEmpty()) {
            // 如果Redis没有数据，返回空结果或从HBase查询历史数据
            return createEmptyDailyResponse(dateKey);
        }

        return parseDailySalesResponse(dailyStats);
    }

    /**
     * 获取当日订单数量统计
     */
    @Override
    public DailyOrdersResponse getDailyOrders(String date) {
        String dateKey = date != null ? date : LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));

        // 从Redis获取当日订单数
        String orderCountStr = redisService.hget("statistics:sales:daily:" + dateKey, "orders");
        Integer orderCount = orderCountStr != null ? Integer.parseInt(orderCountStr) : 0;

        String lastUpdateStr = redisService.hget("statistics:sales:daily:" + dateKey, "lastUpdate");
        LocalDateTime lastUpdate = lastUpdateStr != null ?
            LocalDateTime.ofInstant(Instant.ofEpochMilli(Long.parseLong(lastUpdateStr)), ZoneId.systemDefault())
            : LocalDateTime.now();

        return new DailyOrdersResponse(dateKey, orderCount, lastUpdate);
    }

    /**
     * 获取最畅销商品排行榜
     */
    @Override
    public TopProductsResponse getTopProducts(int limit) {
        List<TopProductDto> topProducts = new ArrayList<>();

        // 从Redis Sorted Set获取排行榜
        Set<String> productIds = redisService.zrevrange("statistics:product:sales:rank", 0, limit - 1);

        int rank = 1;
        for (String productId : productIds) {
            // 获取商品详细信息
            Map<String, String> productStats = redisService.hgetAll("statistics:product:sales:" + productId);
            if (!productStats.isEmpty()) {
                TopProductDto dto = new TopProductDto();
                dto.setRank(rank++);
                dto.setProductId(productId);
                dto.setProductName(productStats.get("name"));
                dto.setTotalSales(Integer.parseInt(productStats.get("totalSales")));

                String lastUpdateStr = productStats.get("lastUpdate");
                if (lastUpdateStr != null) {
                    dto.setLastUpdateTime(LocalDateTime.ofInstant(
                        Instant.ofEpochMilli(Long.parseLong(lastUpdateStr)), ZoneId.systemDefault()));
                }

                topProducts.add(dto);
            }
        }

        return new TopProductsResponse(topProducts);
    }

    /**
     * 订单完成时将订单ID写入待更新队列
     */
    @Override
    public void enqueueOrderForStatisticsUpdate(String orderId) {
        if (orderId == null) {
            return;
        }

        try {
            // 将订单ID写入待更新队列
            redisService.lpush("statistics:update:queue", orderId);
            logger.info("Enqueued order for statistics update: {}", orderId);
        } catch (Exception e) {
            logger.error("Failed to enqueue order for statistics update: {}", orderId, e);
        }
    }

    /**
     * 定时任务：批量处理待更新的订单统计数据
     * 每20秒执行一次
     */
    @Scheduled(fixedRate = 20000)
    public void processPendingStatisticsUpdates() {
        try {
            String today = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
            int batchSize = 1000; // 每次最多处理1000条
            int processedCount = 0;

            for (int i = 0; i < batchSize; i++) {
                // 从队列中取出订单ID
                String orderId = redisService.rpop("statistics:update:queue");
                if (orderId == null) {
                    break; // 队列为空
                }

                // 检查是否已处理（去重）
                if (redisService.sismember("statistics:processed:orders:" + today, orderId)) {
                    logger.debug("Order already processed, skipping: {}", orderId);
                    continue;
                }

                // 查询订单详情
                Order order = orderHBaseService.getOrderById(orderId);
                if (order == null || order.getStatus() != OrderStatus.COMPLETED) {
                    logger.warn("Order not found or not completed, skipping: {}", orderId);
                    continue;
                }

                // 更新统计数据
                updateTotalSales(order.getActualAmount());
                updateDailySales(order);
                updateProductSalesStatistics(order);

                // 记录已处理
                redisService.sadd("statistics:processed:orders:" + today, orderId);
                redisService.expire("statistics:processed:orders:" + today, 86400); // 24小时过期

                processedCount++;
            }

            if (processedCount > 0) {
                logger.info("Processed {} orders for statistics update", processedCount);
            }
        } catch (Exception e) {
            logger.error("Failed to process pending statistics updates", e);
        }
    }

    // 私有方法实现
    private void updateTotalSales(BigDecimal amount) {
        // 更新总销售额
        redisService.incrByFloat("statistics:sales:total", amount.doubleValue());

        // 更新已完成订单数
        redisService.incr("statistics:sales:total:count");

        // 更新最后更新时间
        redisService.setString("statistics:sales:total:update",
            String.valueOf(System.currentTimeMillis()));
    }

    private void updateDailySales(Order order) {
        // 使用订单完成时间作为统计日期
        String dateKey = order.getCompleteTime().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
        String hashKey = "statistics:sales:daily:" + dateKey;

        // 增加销售额
        redisService.hincrByFloat(hashKey, "sales", order.getActualAmount().doubleValue());

        // 增加订单数
        redisService.hincrBy(hashKey, "orders", 1);

        // 更新最后更新时间
        redisService.hset(hashKey, "lastUpdate", String.valueOf(System.currentTimeMillis()));

        // 设置过期时间（30天）
        redisService.expire(hashKey, 2592000);
    }

    private void updateProductSalesStatistics(Order order) {
        if (order.getItems() != null) {
            for (Order.OrderItem item : order.getItems()) {
                String productId = item.getProductId();
                int quantity = item.getQuantity();

                // 更新销量排行榜
                redisService.zincrby("statistics:product:sales:rank", quantity, productId);

                // 更新商品销量详情
                String detailKey = "statistics:product:sales:" + productId;
                redisService.hincrBy(detailKey, "totalSales", quantity);
                redisService.hset(detailKey, "lastUpdate", String.valueOf(System.currentTimeMillis()));

                // 设置商品名称（如果还没有设置）
                if (redisService.hget(detailKey, "name") == null) {
                    try {
                        Product product = productService.getProduct(productId);
                        if (product != null) {
                            redisService.hset(detailKey, "name", product.getName());
                        }
                    } catch (Exception e) {
                        logger.warn("Failed to get product name for statistics: {}", productId, e);
                    }
                }
            }
        }
    }

    private void cacheTotalSales(TotalSalesResponse response) {
        redisService.setString("statistics:sales:total", response.getTotalSales().toString());
        redisService.setString("statistics:sales:total:update",
            response.getLastUpdateTime().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
        // 设置过期时间为1小时
        redisService.expire("statistics:sales:total", 3600);
        redisService.expire("statistics:sales:total:update", 3600);
    }

    private Integer getCompletedOrderCount() {
        Map<String, Long> statusStats = redisService.getOrderStatusStatistics();
        return statusStats.get("COMPLETED").intValue();
    }
}
```

### SalesStatisticsHBaseService 设计

```java
@Service
public class SalesStatisticsHBaseService {

    @Autowired
    private Connection hBaseConnection;

    /**
     * 计算总销售额（从HBase查询所有已完成订单）
     */
    public TotalSalesResponse calculateTotalSales() throws IOException {
        BigDecimal totalSales = BigDecimal.ZERO;
        int completedOrders = 0;

        try (Table table = hBaseConnection.getTable(TableName.valueOf(OrderConstants.ORDER_TABLE_NAME))) {
            Scan scan = new Scan();
            // 只查询COMPLETED状态的订单
            SingleColumnValueFilter statusFilter = new SingleColumnValueFilter(
                Bytes.toBytes(OrderConstants.CF_BASE),
                Bytes.toBytes("status"),
                CompareFilter.CompareOp.EQUAL,
                Bytes.toBytes(OrderStatus.COMPLETED.name())
            );
            scan.setFilter(statusFilter);

            try (ResultScanner scanner = table.getScanner(scan)) {
                for (Result result : scanner) {
                    // 解析订单金额
                    byte[] amountBytes = result.getValue(
                        Bytes.toBytes(OrderConstants.CF_BASE),
                        Bytes.toBytes("actual_amount")
                    );

                    if (amountBytes != null) {
                        String amountStr = Bytes.toString(amountBytes);
                        totalSales = totalSales.add(new BigDecimal(amountStr));
                        completedOrders++;
                    }
                }
            }
        }

        return new TotalSalesResponse(totalSales, completedOrders, LocalDateTime.now());
    }

    /**
     * 计算指定日期的销售额统计
     */
    public DailySalesResponse calculateDailySales(String date) throws IOException {
        // 实现日期范围查询逻辑
        // ... 省略具体实现
        return new DailySalesResponse();
    }
}
```

## 控制器层设计

### SalesStatisticsController 设计

```java
@RestController
@RequestMapping("/api/statistics")
@Profile("dev")  // 仅开发环境启用
public class SalesStatisticsController {

    @Autowired
    private SalesStatisticsService statisticsService;

    /**
     * 获取总销售额统计
     */
    @GetMapping("/total-sales")
    public ApiResponse<TotalSalesResponse> getTotalSales() {
        try {
            TotalSalesResponse response = statisticsService.getTotalSales();
            return ApiResponse.success(response);
        } catch (Exception e) {
            return ApiResponse.error("获取总销售额统计失败: " + e.getMessage());
        }
    }

    /**
     * 获取当日销售额统计
     */
    @GetMapping("/daily-sales")
    public ApiResponse<DailySalesResponse> getDailySales(
            @RequestParam(required = false) String date) {
        try {
            DailySalesResponse response = statisticsService.getDailySales(date);
            return ApiResponse.success(response);
        } catch (Exception e) {
            return ApiResponse.error("获取当日销售额统计失败: " + e.getMessage());
        }
    }

    /**
     * 获取当日订单数量统计
     */
    @GetMapping("/daily-orders")
    public ApiResponse<DailyOrdersResponse> getDailyOrders(
            @RequestParam(required = false) String date) {
        try {
            DailyOrdersResponse response = statisticsService.getDailyOrders(date);
            return ApiResponse.success(response);
        } catch (Exception e) {
            return ApiResponse.error("获取当日订单数量统计失败: " + e.getMessage());
        }
    }

    /**
     * 获取最畅销商品排行榜
     */
    @GetMapping("/top-products")
    public ApiResponse<TopProductsResponse> getTopProducts(
            @RequestParam(defaultValue = "3") int limit) {
        try {
            if (limit <= 0 || limit > 20) {
                return ApiResponse.error("limit参数必须在1-20之间");
            }

            TopProductsResponse response = statisticsService.getTopProducts(limit);
            return ApiResponse.success(response);
        } catch (Exception e) {
            return ApiResponse.error("获取畅销商品排行榜失败: " + e.getMessage());
        }
    }
}
```

## 数据统计策略

### 实时更新策略

#### 订单完成事件触发统计更新
```java
// 在OrderServiceImpl的订单状态更新方法中添加统计更新
if (newStatus == OrderStatus.COMPLETED) {
    // 将订单ID写入待更新队列，由定时任务批量处理
    salesStatisticsService.enqueueOrderForStatisticsUpdate(order.getOrderId());
}
```

#### 定时任务更新复杂统计
```java
@Component
public class SalesStatisticsScheduledTask {

    @Autowired
    private SalesStatisticsService statisticsService;

    @Autowired
    private SalesStatisticsHBaseService hBaseService;

    @Autowired
    private RedisService redisService;

    /**
     * 每20秒批量处理待更新的订单统计数据
     * 这是核心的准实时更新机制
     */
    @Scheduled(fixedRate = 20000)
    public void processPendingStatisticsUpdates() {
        // 实现见SalesStatisticsServiceImpl
        statisticsService.processPendingStatisticsUpdates();
    }

    /**
     * 每天凌晨2点从HBase重新计算校准Redis数据
     * 确保数据准确性
     */
    @Scheduled(cron = "0 0 2 * * ?")
    public void recalculateStatisticsFromHBase() {
        try {
            logger.info("Starting daily statistics recalculation from HBase");

            // 1. 重新计算总销售额
            TotalSalesResponse totalSales = hBaseService.calculateTotalSales();
            redisService.setString("statistics:sales:total", totalSales.getTotalSales().toString());
            redisService.setString("statistics:sales:total:count", String.valueOf(totalSales.getCompletedOrders()));
            redisService.setString("statistics:sales:total:update", String.valueOf(System.currentTimeMillis()));

            // 2. 重新计算当日销售额
            String today = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
            DailySalesResponse dailySales = hBaseService.calculateDailySales(today);
            String hashKey = "statistics:sales:daily:" + today;
            redisService.hset(hashKey, "sales", dailySales.getDailySales().toString());
            redisService.hset(hashKey, "orders", String.valueOf(dailySales.getOrderCount()));
            redisService.hset(hashKey, "lastUpdate", String.valueOf(System.currentTimeMillis()));
            redisService.expire(hashKey, 2592000); // 30天过期

            // 3. 清空已处理订单集合，准备新的一天
            String yesterday = LocalDate.now().minusDays(1).format(DateTimeFormatter.ofPattern("yyyyMMdd"));
            redisService.del("statistics:processed:orders:" + yesterday);

            logger.info("Daily statistics recalculation completed successfully");
        } catch (Exception e) {
            logger.error("定时校准统计数据失败", e);
        }
    }
}
```

### 数据一致性保障

#### Redis数据持久化
- **RDB快照**：定期全量备份统计数据
- **AOF日志**：记录所有统计数据更新操作
- **主从复制**：Redis集群确保数据高可用

#### 统计数据校验
```java
public class StatisticsDataValidator {

    /**
     * 校验统计数据一致性
     */
    public void validateStatisticsConsistency() {
        // 1. 校验总销售额 = 所有已完成订单金额之和
        // 2. 校验商品总销量 = 所有订单中该商品销量之和
        // 3. 校验当日统计数据准确性
    }
}
```

## 性能优化策略

### 缓存优化

#### 多级缓存策略
- **L1缓存**：Redis本地缓存，毫秒级响应
- **L2缓存**：应用内存缓存，微秒级响应
- **持久化缓存**：HBase历史数据缓存

#### 缓存更新策略
- **写时更新**：订单完成时实时更新统计缓存
- **定时刷新**：复杂统计定时刷新缓存
- **懒加载**：查询时缓存不存在则计算并缓存

### 查询优化

#### HBase查询优化
- **RowKey设计**：按日期前缀设计，便于范围查询
- **列族优化**：统计相关字段放在同一列族
- **批量查询**：使用批量操作减少网络往返

#### Redis查询优化
- **Pipeline操作**：批量Redis操作减少网络延迟
- **连接池优化**：复用Redis连接提高性能
- **数据结构选择**：合理选择Hash、Sorted Set等结构

### 并发处理

#### 统计数据并发更新
```java
public void updateDailySales(Order order) {
    String dateKey = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
    String lockKey = "lock:statistics:daily:" + dateKey;

    try {
        // 获取分布式锁
        if (redisService.setnx(lockKey, "1")) {
            redisService.expire(lockKey, 10); // 10秒过期

            // 原子更新当日统计
            updateDailySalesAtomic(order);

        } else {
            // 锁被占用，稍后重试或异步处理
            scheduleRetryUpdate(order);
        }
    } finally {
        redisService.del(lockKey);
    }
}
```

## 测试策略

### 单元测试

#### SalesStatisticsServiceTest
```java
@SpringBootTest
public class SalesStatisticsServiceTest {

    @Autowired
    private SalesStatisticsService statisticsService;

    @Autowired
    private RedisService redisService;

    @Test
    public void testGetTotalSales() {
        // 准备测试数据
        prepareTestData();

        // 执行测试
        TotalSalesResponse response = statisticsService.getTotalSales();

        // 验证结果
        assertThat(response.getTotalSales()).isGreaterThan(BigDecimal.ZERO);
        assertThat(response.getCompletedOrders()).isGreaterThan(0);
    }

    @Test
    public void testUpdateStatisticsOnOrderComplete() {
        // 创建测试订单
        Order testOrder = createTestOrder();

        // 记录更新前的数据
        BigDecimal beforeTotalSales = getCurrentTotalSales();

        // 执行更新
        statisticsService.updateStatisticsOnOrderComplete(testOrder);

        // 验证统计数据已更新
        BigDecimal afterTotalSales = getCurrentTotalSales();
        assertThat(afterTotalSales).isEqualTo(beforeTotalSales.add(testOrder.getActualAmount()));
    }
}
```

### 集成测试

#### 统计接口集成测试
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class SalesStatisticsIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    public void testGetTotalSalesEndpoint() {
        ResponseEntity<ApiResponse> response = restTemplate.getForEntity(
            "/api/statistics/total-sales", ApiResponse.class);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getCode()).isEqualTo(200);
    }

    @Test
    public void testStatisticsDataConsistency() {
        // 测试统计数据与订单数据的一致性
        // 1. 创建多个订单
        // 2. 查询统计数据
        // 3. 验证统计数据准确性
    }
}
```

### 性能测试

#### JMeter压力测试
- **并发用户数**：100并发用户
- **请求频率**：每秒10次请求
- **测试接口**：
  - `/api/statistics/total-sales`
  - `/api/statistics/daily-sales`
  - `/api/statistics/top-products`
- **性能指标**：
  - 平均响应时间 < 500ms
  - 95%响应时间 < 1000ms
  - 错误率 < 1%

## 实施计划

### 第一阶段：基础框架搭建（1-2天）
- [ ] 创建SalesStatisticsService接口和实现类
- [ ] 创建SalesStatisticsHBaseService
- [ ] 创建统计相关的DTO类
- [ ] 配置定时任务

### 第二阶段：核心功能实现（2-3天）
- [ ] 实现总销售额统计功能
- [ ] 实现当日销售额统计功能
- [ ] 实现当日订单数量统计功能
- [ ] 实现最畅销商品排行榜功能

### 第三阶段：控制器和接口开发（1-2天）
- [ ] 创建SalesStatisticsController
- [ ] 实现所有API接口
- [ ] 添加参数校验和异常处理
- [ ] 更新Swagger文档

### 第四阶段：数据统计策略优化（1-2天）
- [ ] 实现订单完成时统计数据实时更新
- [ ] 实现定时任务更新复杂统计
- [ ] 实现数据一致性校验
- [ ] 性能优化和缓存策略

### 第五阶段：测试和部署（2-3天）
- [ ] 编写单元测试
- [ ] 编写集成测试
- [ ] 性能测试和优化
- [ ] 部署到开发环境
- [ ] 更新API文档

### 验收标准
- [ ] 所有统计接口响应时间 < 500ms
- [ ] 统计数据与订单数据完全一致
- [ ] 支持高并发访问（100+并发）
- [ ] 实时统计数据更新延迟 < 1秒
- [ ] 完整的单元测试覆盖率 > 80%

### 风险评估

#### 技术风险
- **数据一致性风险**：通过分布式锁和数据校验机制降低
- **性能风险**：通过多级缓存和查询优化降低
- **并发更新风险**：通过Redis原子操作和分布式锁控制

#### 业务风险
- **统计数据准确性**：通过数据校验和定期对账确保
- **历史数据迁移**：通过定时任务逐步迁移历史统计数据

### 后续优化计划
- [ ] 实现更详细的销售分析报表
- [ ] 添加销售趋势图表功能
- [ ] 实现实时数据流处理
- [ ] 添加数据导出功能
