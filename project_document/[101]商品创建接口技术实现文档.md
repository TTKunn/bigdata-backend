# [101] 商品创建接口技术实现文档

## 文档信息

| 文档编号 | [101] |
|----------|-------|
| 文档名称 | 商品创建接口技术实现文档 |
| 版本号 | 1.0 |
| 创建日期 | 2026-01-07 |
| 作者 | 技术架构师 |
| 项目名称 | 大数据商城后端系统 |

## 目录

1. [概述](#概述)
2. [接口设计](#接口设计)
3. [数据模型设计](#数据模型设计)
4. [存储架构设计](#存储架构设计)
5. [缓存策略](#缓存策略)
6. [实现方案](#实现方案)
7. [错误处理](#错误处理)
8. [性能优化](#性能优化)
9. [测试方案](#测试方案)
10. [部署配置](#部署配置)

## 概述

### 项目背景

本接口是大数据商城后端系统商品管理模块的核心功能之一，主要用于开发环境的商品数据创建。该接口仅在开发和测试阶段使用，不会在生产环境中暴露，目的是为开发团队提供便捷的商品数据创建能力。

### 设计目标

1. **大数据技术集成**：充分利用HBase、HDFS、Redis等大数据技术栈
2. **高性能存储**：实现商品数据的快速写入和查询
3. **缓存优化**：通过Redis缓存提升查询性能
4. **数据一致性**：确保多存储系统间的数据一致性
5. **扩展性**：支持海量商品数据的存储和管理

### 技术栈

- **后端框架**：Spring Boot 2.x
- **大数据存储**：HBase 2.x, HDFS 3.x
- **缓存系统**：Redis 6.x
- **数据序列化**：FastJSON, Jackson
- **连接客户端**：HBase Java API, Jedis

## 接口设计

### 接口规范

#### 创建商品接口

**接口路径**：`POST /api/product`

**请求头**：
```
Content-Type: application/json
X-API-Key: ${开发环境密钥}  // 开发环境安全验证
```

**请求体**：
```json
{
  "id": "00010001",
  "name": "华为Mate60 Pro",
  "category": "0001",
  "brand": "华为",
  "price": 6999.00,
  "cost": 5500.00,
  "description": "华为旗舰智能手机，HarmonyOS 4.0",
  "spec": {
    "screen": "6.82英寸",
    "processor": "麒麟9000S",
    "memory": "12GB+512GB",
    "camera": "5000万像素"
  },
  "tags": ["旗舰机", "鸿蒙系统", "5G"],
  "images": [
    {
      "file": "base64_encoded_image_data_or_file_url",
      "type": "main",
      "filename": "huawei_mate60_main.jpg"
    }
  ],
  "stock": {
    "total": 1000,
    "safe": 100,
    "warehouse": "BJ001"
  }
}
```

**响应体**：
```json
{
  "code": 200,
  "message": "商品创建成功",
  "data": {
    "productId": "00010001",
    "createTime": "2026-01-07T10:30:00Z",
    "images": [
      {
        "id": "hdfs://bigdata01:9000/product_images/0001/00010001/1704625800000_main.jpg",
        "type": "main",
        "size": 245760
      }
    ]
  }
}
```

### 参数说明

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | string | 是 | 商品ID，全局唯一，建议格式：{category_id(4位)}{product_id(8位)} |
| name | string | 是 | 商品名称 |
| category | string | 是 | 商品分类ID |
| brand | string | 否 | 品牌名称 |
| price | number | 是 | 销售价格 |
| cost | number | 否 | 成本价 |
| description | string | 否 | 商品描述 |
| spec | object | 否 | 商品规格参数 |
| tags | array | 否 | 商品标签数组 |
| images | array | 否 | 商品图片数组 |
| stock | object | 否 | 库存信息 |

## 数据模型设计

### 商品实体模型

```java
public class Product {
    private String id;
    private String name;
    private String category;
    private String brand;
    private BigDecimal price;
    private BigDecimal cost;
    private String description;
    private Map<String, Object> spec;
    private List<String> tags;
    private List<ProductImage> images;
    private ProductStock stock;
    private ProductStatus status;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}

// 商品图片模型
public class ProductImage {
    private String id;        // HDFS路径
    private String type;      // main, detail, thumbnail
    private String filename;
    private long size;
    private LocalDateTime uploadTime;
}

// 商品库存模型
public class ProductStock {
    private int total;
    private int safe;
    private int lock;
    private String warehouse;
}
```

### HBase表结构设计

#### 1. 商品信息主表 (product_info)

**RowKey设计**：`{category_id}_{product_id}_{timestamp}`
- category_id：分类ID（4位）
- product_id：商品ID（8位）
- timestamp：时间戳（13位）

**列族结构**：
```
product_info
├── cf_base (商品基本信息)
│   ├── name: 商品名称
│   ├── category: 品类编号
│   ├── brand: 品牌
│   ├── price: 价格
│   ├── cost: 成本价
│   ├── status: 状态
│   └── create_time: 创建时间
├── cf_detail (商品详细信息)
│   ├── description: 描述
│   ├── spec: 规格参数
│   ├── image: 图片信息JSON对象（包含HDFS路径、类型、大小等元数据）
│   └── tags: 标签
├── cf_stock (库存信息)
│   ├── total_stock: 总库存
│   ├── warehouse_stock: 仓库库存
│   ├── safe_stock: 安全库存
│   └── lock_stock: 锁定库存
└── cf_stat (统计信息)
    ├── view_count: 浏览数
    ├── sale_count: 销量
    ├── collect_count: 收藏数
    └── update_time: 更新时间
```

#### 2. 商品图片元数据表 (product_images)

**RowKey设计**：`{product_id}_{image_type}_{timestamp}`

**列族结构**：
```
product_images
└── cf_meta (图片元数据)
    ├── product_id: 关联商品ID
    ├── hdfs_path: HDFS存储路径
    ├── file_size: 文件大小
    ├── upload_time: 上传时间
    └── checksum: 文件校验码
```

## 存储架构设计

### 分层存储架构

```
┌─────────────────┐
│   应用服务层     │
│  ┌────────────┐ │
│  │商品创建接口 │ │
│  └────────────┘ │
└─────────────────┘
         │
    ┌────┴────┐
    │ 缓存层   │ ← Redis缓存
    │ (热点数据)│
    └────┬────┘
         │
    ┌────┴────┐
    │ 存储层   │
    │ ┌─────┬─────┐ │
    │ │HBase│HDFS │ │
    │ │结构化│大文件│ │
    │ └─────┴─────┘ │
    └─────────────────┘
```

### 数据流设计

1. **接收请求**：接口接收商品创建请求
2. **参数校验**：验证必填参数和数据格式
3. **图片处理**：上传图片到HDFS，生成元数据
4. **HBase存储**：将商品信息写入HBase主表
5. **Redis缓存**：更新相关缓存数据
6. **返回结果**：返回创建成功的商品信息

## 缓存策略

### Redis缓存设计

#### 1. 商品基本信息缓存
```redis
# 商品基本信息缓存
HSET product:cache:{product_id} name "商品名" price "价格" stock "库存" category "分类"
EXPIRE product:cache:{product_id} 300  # 5分钟过期
```

#### 2. 商品库存缓存
```redis
# 商品库存缓存（原子操作）
SET stock:{product_id} 1000 EX 3600
```

#### 3. 分类商品列表缓存
```redis
# 分类商品列表缓存
SADD category:products:{category_id} {product_id1} {product_id2}
EXPIRE category:products:{category_id} 600  # 10分钟过期
```

### 缓存更新策略

采用 **Cache-Aside** 模式：
1. **写操作**：先更新HBase，再删除相关缓存
2. **读操作**：先查缓存，缓存不存在再查HBase并回填缓存
3. **过期策略**：基于时间过期 + LRU淘汰

## 实现方案

### 核心服务类设计

#### 1. 商品服务接口
```java
public interface ProductService {
    Product createProduct(CreateProductRequest request);
    Product getProduct(String productId);
    boolean updateProductStock(String productId, int delta);
    List<Product> getProductsByCategory(String categoryId, int page, int size);
}
```

#### 2. 商品服务实现
```java
@Service
public class ProductServiceImpl implements ProductService {
    
    @Autowired
    private HBaseService hBaseService;
    
    @Autowired
    private RedisService redisService;
    
    @Autowired
    private HdfsService hdfsService;
    
    @Transactional
    public Product createProduct(CreateProductRequest request) {
        // 1. 参数校验
        validateRequest(request);
        
        // 2. 处理图片上传到HDFS
        List<ProductImage> images = processImages(request.getImages(), request.getId());
        
        // 3. 构建商品对象
        Product product = buildProduct(request, images);
        
        // 4. 保存到HBase
        hBaseService.saveProduct(product);
        
        // 5. 初始化Redis缓存
        initializeRedisCache(product);
        
        return product;
    }
}
```

#### 3. HBase服务
```java
@Service
public class HBaseService {
    
    public void saveProduct(Product product) {
        // 构建RowKey
        String rowKey = buildRowKey(product);
        
        // 创建Put操作
        Put put = new Put(Bytes.toBytes(rowKey));
        
        // 写入各个列族
        writeBaseInfo(put, product);
        writeDetailInfo(put, product);
        writeStockInfo(put, product);
        
        // 执行写入
        table.put(put);
    }
}
```

#### 4. HDFS服务
```java
@Service
public class HdfsService {
    
    @Autowired
    private FileSystem hdfsFileSystem;
    
    public ProductImage uploadImage(MultipartFile file, String productId, String type) {
        // 生成HDFS路径
        String hdfsPath = generateHdfsPath(productId, type, file.getOriginalFilename());
        
        // 上传文件
        try (FSDataOutputStream output = hdfsFileSystem.create(new Path(hdfsPath))) {
            IOUtils.copy(file.getInputStream(), output);
        }
        
        // 构建图片元数据
        return ProductImage.builder()
                .id(hdfsPath)
                .type(type)
                .filename(file.getOriginalFilename())
                .size(file.getSize())
                .uploadTime(LocalDateTime.now())
                .build();
    }
}
```

#### 5. Redis服务
```java
@Service
public class RedisService {
    
    @Autowired
    private JedisPool jedisPool;
    
    public void cacheProduct(Product product) {
        try (Jedis jedis = jedisPool.getResource()) {
            String key = "product:cache:" + product.getId();
            Map<String, String> data = new HashMap<>();
            data.put("name", product.getName());
            data.put("price", product.getPrice().toString());
            data.put("category", product.getCategory());
            
            jedis.hmset(key, data);
            jedis.expire(key, 300); // 5分钟过期
        }
    }
    
    public void setStock(String productId, int stock) {
        try (Jedis jedis = jedisPool.getResource()) {
            jedis.set("stock:" + productId, String.valueOf(stock));
            jedis.expire("stock:" + productId, 3600); // 1小时过期
        }
    }
}
```

### 控制器实现

```java
@RestController
@RequestMapping("/api")
// 接口直接可用，无需profile限制
public class ProductDevController {
    
    @Autowired
    private ProductService productService;
    
    @PostMapping("/product")
    public ResponseEntity<ApiResponse<Product>> createProduct(
            @RequestBody CreateProductRequest request,
            @RequestHeader("X-API-Key") String apiKey) {
        
        // 开发环境API密钥验证
        if (!isValidApiKey(apiKey)) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(ApiResponse.error("无效的API密钥"));
        }
        
        try {
            Product product = productService.createProduct(request);
            return ResponseEntity.ok(ApiResponse.success(product, "商品创建成功"));
        } catch (ValidationException e) {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error("商品创建失败: " + e.getMessage()));
        }
    }
}
```

## 错误处理

### 异常分类

1. **参数校验异常**：`ValidationException`
2. **存储异常**：`StorageException`
3. **缓存异常**：`CacheException`
4. **网络异常**：`NetworkException`

### 错误码设计

| 错误码 | 说明 | HTTP状态码 |
|--------|------|------------|
| 1001 | 参数校验失败 | 400 |
| 1002 | 商品ID已存在 | 409 |
| 2001 | HBase存储失败 | 500 |
| 2002 | HDFS上传失败 | 500 |
| 3001 | Redis缓存失败 | 500 |

### 补偿机制

1. **HDFS上传失败**：自动清理已上传的图片文件
2. **HBase写入失败**：回滚Redis缓存操作
3. **部分失败**：提供重试机制和手动补偿接口

## 性能优化

### 1. 异步处理
- 图片上传采用异步处理
- 缓存更新采用异步队列
- 大批量数据导入采用批量处理

### 2. 连接池优化
- HBase连接池：最大连接数50
- Redis连接池：最大连接数20
- HTTP客户端连接池：最大连接数100

### 3. 数据压缩
- HDFS文件压缩：使用Snappy压缩
- 网络传输压缩：GZIP压缩
- 缓存数据压缩：减少内存占用

### 4. 监控指标
- 接口响应时间：< 500ms (图片上传 < 2000ms)
- 成功率：> 99.9%
- 并发处理能力：100+ TPS

## 测试方案

### 单元测试
- 服务层方法测试
- 数据转换逻辑测试
- 异常处理测试

### 集成测试
- 完整接口流程测试
- 多存储系统协同测试
- 缓存一致性测试

### 性能测试
- 并发创建测试（50并发）
- 大文件上传测试
- 缓存命中率测试

### 测试数据
```json
// 测试商品数据
{
  "id": "00010001",
  "name": "测试商品",
  "category": "0001",
  "price": 99.99,
  "images": [],
  "stock": {"total": 100}
}
```

## 部署配置

### 开发环境配置

**application.properties**：
```properties
# 应用基本配置
spring.application.name=bigdata-backend
server.port=8080

# 接口直接可用，无需特殊配置

# HBase配置
hbase.zookeeper.quorum=192.168.32.200:2181
hbase.table.name=product_info

# Redis配置
redis.host=192.168.32.200
redis.port=6379
redis.password=

# HDFS配置
hdfs.namenode=192.168.32.200:9000
hdfs.replication=1
```

### 生产环境配置

**application-prod.properties**：
```properties
# 生产环境标识
spring.profiles.active=prod

# 禁用开发接口
api.dev.enabled=false

# 集群配置
hbase.zookeeper.quorum=bigdata01:2181,bigdata02:2181,bigdata03:2181
redis.cluster.nodes=bigdata01:6379,bigdata02:6379,bigdata03:6379
```

---

**文档状态**：草稿
**审核状态**：待审核
**版本控制**：
- v1.0 (2026-01-07)：初始版本，完成商品创建接口技术实现文档
