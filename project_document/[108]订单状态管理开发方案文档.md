# [108] 订单状态管理开发方案文档

## 文档信息

| 文档编号 | [108] |
|----------|-------|
| 文档名称 | 订单状态管理开发方案文档 |
| 版本号 | 1.0 |
| 创建日期 | 2026-01-07 |
| 作者 | 系统架构师 |
| 项目名称 | 大数据商城后端系统 |
| 背景 | 实现订单的支付、取消和完成功能，完善订单状态生命周期管理 |

## 目录

1. [项目背景](#项目背景)
2. [功能需求分析](#功能需求分析)
3. [订单状态设计](#订单状态设计)
4. [API接口设计](#API接口设计)
5. [数据结构设计](#数据结构设计)
6. [服务层设计](#服务层设计)
7. [控制器层设计](#控制器层设计)
8. [库存管理策略](#库存管理策略)
9. [异常处理设计](#异常处理设计)
10. [测试策略](#测试策略)
11. [实施计划](#实施计划)

## 项目背景

### 当前系统状态

根据现有代码分析，系统已实现：
- **订单创建**：从购物车创建订单，扣减库存，生成订单号
- **订单查询**：支持订单列表查询和详情查看
- **基础状态**：PENDING_PAYMENT（待支付）、PAID（已支付）、COMPLETED（已完成）
- **数据存储**：HBase order_history表存储订单数据

### 需求更新

根据业务需求更新，订单状态管理需要完善：
1. **状态调整**：PAID状态同时代表已支付和已发货（简化物流流程）
2. **新增状态**：CANCELLED（已取消），需要库存回库
3. **库存管理**：订单创建时扣减库存，取消时回库
4. **状态流转**：完善订单生命周期管理

### 开发目标

实现订单的完整状态管理，包括支付、取消和完成功能，确保状态流转的业务正确性和数据一致性。

## 功能需求分析

### 核心功能点

#### 1. 订单支付
- **功能描述**：用户完成订单支付，状态从待支付变为已支付/已发货
- **业务规则**：
  - 只能支付待支付状态的订单
  - 支付成功后自动变为已发货状态（简化流程）
  - 记录支付时间
  - 触发后续发货流程（预留）
- **输入参数**：orderId
- **输出结果**：支付结果，更新后的订单状态

#### 2. 订单取消
- **功能描述**：用户取消订单，状态变为已取消
- **业务规则**：
  - 只能取消待支付状态的订单
  - 取消成功后自动回库库存
  - 记录取消时间
  - 订单变为不可操作状态
- **输入参数**：orderId
- **输出结果**：取消结果，更新后的订单状态

#### 3. 订单完成（确认收货）
- **功能描述**：用户确认收货，订单完成
- **业务规则**：
  - 只能完成已支付/已发货状态的订单
  - 记录完成时间
  - 订单变为最终完成状态
  - 可触发后续评价、积分等流程（预留）
- **输入参数**：orderId
- **输出结果**：完成结果，更新后的订单状态

### 业务约束

#### 状态流转约束
```
待支付 (PENDING_PAYMENT)
├── 支付 → 已支付/已发货 (PAID)
└── 取消 → 已取消 (CANCELLED)

已支付/已发货 (PAID)
└── 确认收货 → 已完成 (COMPLETED)

已取消 (CANCELLED) - 终态
已完成 (COMPLETED) - 终态
```

#### 库存管理规则
- **订单创建**：立即扣减库存，确保库存充足
- **订单取消**：立即回库库存，恢复可用库存
- **订单完成**：库存无需变动，已确认销售
- **异常处理**：操作失败时确保库存数据一致性

## 订单状态设计

### 状态枚举更新

```java
public enum OrderStatus {
    PENDING_PAYMENT("待支付"),      // 订单创建后的初始状态
    PAID("已支付"),                 // 已支付，同时代表已发货（简化流程）
    COMPLETED("已完成"),            // 已确认收货，订单完成
    CANCELLED("已取消");            // 订单已取消

    private final String description;

    OrderStatus(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```

### 状态流转规则

#### 允许的状态转换
```java
// 待支付 → 已支付
PENDING_PAYMENT → PAID

// 待支付 → 已取消  
PENDING_PAYMENT → CANCELLED

// 已支付 → 已完成
PAID → COMPLETED
```

#### 禁止的状态转换
- 已取消和已完成的订单不能再进行任何状态转换
- 不能跳跃状态转换（如待支付直接到已完成）
- 不能逆向状态转换（如已完成回到已支付）

#### 状态转换验证
```java
public boolean canTransitionTo(OrderStatus newStatus) {
    switch (this) {
        case PENDING_PAYMENT:
            return newStatus == PAID || newStatus == CANCELLED;
        case PAID:
            return newStatus == COMPLETED;
        case COMPLETED:
        case CANCELLED:
            return false; // 终态不能转换
        default:
            return false;
    }
}
```

### 时间戳管理

#### 订单时间字段
- **createTime**：订单创建时间
- **payTime**：支付完成时间（状态变更为PAID时更新）
- **cancelTime**：取消时间（状态变更为CANCELLED时更新）
- **completeTime**：完成时间（状态变更为COMPLETED时更新）

#### 时间更新规则
- 创建订单时：设置createTime
- 支付订单时：设置payTime
- 取消订单时：设置cancelTime
- 完成订单时：设置completeTime

## API接口设计

### 接口路径规划

```
POST   /api/order/{orderId}/pay        # 支付订单
POST   /api/order/{orderId}/cancel     # 取消订单
POST   /api/order/{orderId}/complete   # 完成订单（确认收货）
GET    /api/order/{orderId}            # 查询订单详情（预留）
```

### 接口详细设计

#### 1. 支付订单

**接口路径**：`POST /api/order/{orderId}/pay`

**请求参数**：无（从路径获取orderId）

**业务逻辑**：
1. 验证订单存在
2. 检查订单状态为待支付
3. 更新订单状态为已支付
4. 记录支付时间
5. 更新HBase数据

**响应结果**：
```json
{
  "code": 200,
  "message": "支付成功",
  "timestamp": "2026-01-07T10:30:00Z",
  "data": {
    "orderId": "20260107103000000001",
    "status": "PAID",
    "payTime": "2026-01-07T10:30:00Z"
  }
}
```

#### 2. 取消订单

**接口路径**：`POST /api/order/{orderId}/cancel`

**请求参数**：无（从路径获取orderId）

**业务逻辑**：
1. 验证订单存在
2. 检查订单状态为待支付
3. 回库订单商品库存
4. 更新订单状态为已取消
5. 记录取消时间
6. 更新HBase数据

**响应结果**：
```json
{
  "code": 200,
  "message": "取消成功",
  "timestamp": "2026-01-07T10:30:00Z",
  "data": {
    "orderId": "20260107103000000001",
    "status": "CANCELLED",
    "cancelTime": "2026-01-07T10:30:00Z"
  }
}
```

#### 3. 完成订单（确认收货）

**接口路径**：`POST /api/order/{orderId}/complete`

**请求参数**：无（从路径获取orderId）

**业务逻辑**：
1. 验证订单存在
2. 检查订单状态为已支付
3. 更新订单状态为已完成
4. 记录完成时间
5. 更新HBase数据

**响应结果**：
```json
{
  "code": 200,
  "message": "确认收货成功",
  "timestamp": "2026-01-07T10:30:00Z",
  "data": {
    "orderId": "20260107103000000001",
    "status": "COMPLETED",
    "completeTime": "2026-01-07T10:30:00Z"
  }
}
```

## 数据结构设计

### 请求DTO设计

#### OrderOperationRequest
```java
public class OrderOperationRequest {
    @NotBlank(message = "订单ID不能为空")
    private String orderId;
}
```

### 响应DTO设计

#### OrderStatusUpdateResponse
```java
public class OrderStatusUpdateResponse {
    private String orderId;
    private OrderStatus status;
    private LocalDateTime payTime;      // 支付时更新
    private LocalDateTime cancelTime;   // 取消时更新
    private LocalDateTime completeTime; // 完成时更新
    private String message;
}
```

### 模型更新

#### Order模型扩展
```java
public class Order {
    private String orderId;
    private String userId;
    private BigDecimal totalAmount;
    private BigDecimal discountAmount;
    private BigDecimal actualAmount;
    private OrderStatus status;
    private LocalDateTime createTime;
    private LocalDateTime payTime;      // 新增
    private LocalDateTime cancelTime;   // 新增
    private LocalDateTime completeTime; // 新增
    private List<OrderItem> items;
    private OrderAddress address;

    // 状态转换方法
    public boolean canTransitionTo(OrderStatus newStatus) {
        // 实现状态转换验证逻辑
    }

    // 时间更新方法
    public void updatePayTime() {
        this.payTime = LocalDateTime.now();
    }

    public void updateCancelTime() {
        this.cancelTime = LocalDateTime.now();
    }

    public void updateCompleteTime() {
        this.completeTime = LocalDateTime.now();
    }
}
```

## 服务层设计

### OrderService接口扩展

```java
public interface OrderService {

    // 现有方法保持不变...

    /**
     * 支付订单
     * @param orderId 订单ID
     * @return 状态更新结果
     */
    OrderStatusUpdateResponse payOrder(String orderId);

    /**
     * 取消订单
     * @param orderId 订单ID
     * @return 状态更新结果
     */
    OrderStatusUpdateResponse cancelOrder(String orderId);

    /**
     * 完成订单（确认收货）
     * @param orderId 订单ID
     * @return 状态更新结果
     */
    OrderStatusUpdateResponse completeOrder(String orderId);

    /**
     * 查询订单详情
     * @param orderId 订单ID
     * @return 订单详情
     */
    OrderDetailDto getOrderDetail(String orderId);
}
```

### OrderServiceImpl实现扩展

```java
@Service
public class OrderServiceImpl implements OrderService {

    // 现有代码保持不变...

    /**
     * 支付订单
     */
    @Override
    @Transactional
    public OrderStatusUpdateResponse payOrder(String orderId) {
        logger.info("Paying order: {}", orderId);

        // 1. 查询订单
        Order order = orderHBaseService.getOrderById(orderId);
        if (order == null) {
            throw new OrderNotFoundException(orderId);
        }

        // 2. 验证状态
        if (order.getStatus() != OrderStatus.PENDING_PAYMENT) {
            throw new InvalidOrderStatusException(
                String.format("订单状态不允许支付，当前状态：%s", order.getStatus().getDescription()));
        }

        // 3. 更新状态和时间
        order.setStatus(OrderStatus.PAID);
        order.updatePayTime();

        // 4. 保存到HBase
        orderHBaseService.updateOrder(order);

        logger.info("Successfully paid order: {}", orderId);
        return buildStatusUpdateResponse(order, "支付成功");
    }

    /**
     * 取消订单
     */
    @Override
    @Transactional
    public OrderStatusUpdateResponse cancelOrder(String orderId) {
        logger.info("Cancelling order: {}", orderId);

        // 1. 查询订单
        Order order = orderHBaseService.getOrderById(orderId);
        if (order == null) {
            throw new OrderNotFoundException(orderId);
        }

        // 2. 验证状态
        if (order.getStatus() != OrderStatus.PENDING_PAYMENT) {
            throw new InvalidOrderStatusException(
                String.format("订单状态不允许取消，当前状态：%s", order.getStatus().getDescription()));
        }

        // 3. 回库库存
        restoreStockForOrder(order.getItems());

        // 4. 更新状态和时间
        order.setStatus(OrderStatus.CANCELLED);
        order.updateCancelTime();

        // 5. 保存到HBase
        orderHBaseService.updateOrder(order);

        logger.info("Successfully cancelled order: {}", orderId);
        return buildStatusUpdateResponse(order, "取消成功");
    }

    /**
     * 完成订单
     */
    @Override
    @Transactional
    public OrderStatusUpdateResponse completeOrder(String orderId) {
        logger.info("Completing order: {}", orderId);

        // 1. 查询订单
        Order order = orderHBaseService.getOrderById(orderId);
        if (order == null) {
            throw new OrderNotFoundException(orderId);
        }

        // 2. 验证状态
        if (order.getStatus() != OrderStatus.PAID) {
            throw new InvalidOrderStatusException(
                String.format("订单状态不允许完成，当前状态：%s", order.getStatus().getDescription()));
        }

        // 3. 更新状态和时间
        order.setStatus(OrderStatus.COMPLETED);
        order.updateCompleteTime();

        // 4. 保存到HBase
        orderHBaseService.updateOrder(order);

        logger.info("Successfully completed order: {}", orderId);
        return buildStatusUpdateResponse(order, "确认收货成功");
    }

    /**
     * 查询订单详情
     */
    @Override
    public OrderDetailDto getOrderDetail(String orderId) {
        logger.info("Getting order detail: {}", orderId);

        Order order = orderHBaseService.getOrderById(orderId);
        if (order == null) {
            throw new OrderNotFoundException(orderId);
        }

        return convertToOrderDetailDto(order);
    }

    // 辅助方法
    private void restoreStockForOrder(List<Order.OrderItem> items) {
        logger.debug("Restoring stock for {} items", items.size());
        for (Order.OrderItem item : items) {
            redisService.restoreStock(item.getProductId(), item.getQuantity());
            logger.debug("Restored {} units of stock for product: {}",
                item.getQuantity(), item.getProductId());
        }
    }

    private OrderStatusUpdateResponse buildStatusUpdateResponse(Order order, String message) {
        OrderStatusUpdateResponse response = new OrderStatusUpdateResponse();
        response.setOrderId(order.getOrderId());
        response.setStatus(order.getStatus());
        response.setPayTime(order.getPayTime());
        response.setCancelTime(order.getCancelTime());
        response.setCompleteTime(order.getCompleteTime());
        response.setMessage(message);
        return response;
    }
}
```

### OrderHBaseService扩展

```java
@Service
public class OrderHBaseService {

    // 现有方法保持不变...

    /**
     * 更新订单（状态变更时使用）
     */
    public void updateOrder(Order order) throws IOException {
        if (order == null || order.getOrderId() == null) {
            throw new IllegalArgumentException("订单或订单ID不能为空");
        }

        logger.info("Updating order in HBase: orderId={}, status={}",
            order.getOrderId(), order.getStatus());

        // 生成RowKey（与保存订单时相同的格式）
        String rowKey = generateRowKey(order.getOrderId(), order.getCreateTime());

        try (Table table = hBaseConnection.getTable(tableName)) {
            Put put = new Put(Bytes.toBytes(rowKey));

            // 更新订单状态
            put.addColumn(cfBaseBytes, Bytes.toBytes("status"),
                Bytes.toBytes(order.getStatus().name()));

            // 更新时间戳字段
            if (order.getPayTime() != null) {
                put.addColumn(cfBaseBytes, Bytes.toBytes("pay_time"),
                    Bytes.toBytes(order.getPayTime().toString()));
            }

            if (order.getCancelTime() != null) {
                put.addColumn(cfBaseBytes, Bytes.toBytes("cancel_time"),
                    Bytes.toBytes(order.getCancelTime().toString()));
            }

            if (order.getCompleteTime() != null) {
                put.addColumn(cfBaseBytes, Bytes.toBytes("complete_time"),
                    Bytes.toBytes(order.getCompleteTime().toString()));
            }

            // 更新修改时间
            put.addColumn(cfBaseBytes, Bytes.toBytes("update_time"),
                Bytes.toBytes(LocalDateTime.now().toString()));

            table.put(put);
            logger.info("Successfully updated order in HBase: {}", order.getOrderId());
        } catch (IOException e) {
            logger.error("Failed to update order in HBase: {}", order.getOrderId(), e);
            throw e;
        }
    }

    /**
     * 根据订单ID查询订单
     */
    public Order getOrderById(String orderId) throws IOException {
        if (orderId == null || orderId.trim().isEmpty()) {
            throw new IllegalArgumentException("订单ID不能为空");
        }

        logger.info("Getting order from HBase: orderId={}", orderId);

        // 使用订单ID前缀扫描（因为RowKey包含日期和序列号）
        String datePrefix = orderId.substring(0, 8); // yyyyMMdd
        String startRow = datePrefix + "_";
        String stopRow = datePrefix + "_" + Character.MAX_VALUE;

        try (Table table = hBaseConnection.getTable(tableName);
             ResultScanner scanner = table.getScanner(
                 new Scan()
                     .withStartRow(Bytes.toBytes(startRow))
                     .withStopRow(Bytes.toBytes(stopRow))
             )) {

            for (Result result : scanner) {
                Order order = parseOrderFromResult(result);
                if (order != null && orderId.equals(order.getOrderId())) {
                    logger.info("Found order in HBase: {}", orderId);
                    return order;
                }
            }
        } catch (IOException e) {
            logger.error("Failed to get order from HBase: {}", orderId, e);
            throw e;
        }

        logger.warn("Order not found in HBase: {}", orderId);
        return null;
    }

    /**
     * 从HBase Result解析订单对象
     */
    private Order parseOrderFromResult(Result result) {
        // 实现订单解析逻辑（与现有的getOrders方法中的解析逻辑类似）
        // 需要解析所有字段，包括新增的cancelTime和completeTime
    }

    /**
     * 生成RowKey
     */
    private String generateRowKey(String orderId, LocalDateTime createTime) {
        // 格式：yyyyMMdd_序列号_时间戳
        String date = orderId.substring(0, 8);
        String sequence = orderId.substring(14);
        long timestamp = createTime != null ?
            createTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli() :
            System.currentTimeMillis();
        return date + "_" + sequence + "_" + timestamp;
    }
}
```

### RedisService扩展

```java
@Service
public class RedisService {

    // 现有方法保持不变...

    /**
     * 回库库存（取消订单时使用）
     * 改名为restoreStock避免与事务回滚混淆
     */
    public void restoreStock(String productId, int quantity) {
        String key = "stock:" + productId;
        jedis.incrBy(key, quantity);
        logger.debug("Restored {} units of stock for product: {}", quantity, productId);
    }

    /**
     * 增加订单状态计数
     */
    public void incrementOrderStatusCount(OrderStatus status) {
        String today = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));

        // 增加总订单数
        jedis.incr("order:count:total");

        // 增加状态计数
        jedis.incr("order:count:status:" + status.name());

        // 增加每日订单数
        jedis.incr("order:count:daily:" + today);

        // 增加每日状态计数
        jedis.incr("order:count:daily:" + today + ":" + status.name());
    }

    /**
     * 减少订单状态计数
     */
    public void decrementOrderStatusCount(OrderStatus status) {
        String today = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));

        // 减少状态计数
        jedis.decr("order:count:status:" + status.name());

        // 减少每日状态计数
        jedis.decr("order:count:daily:" + today + ":" + status.name());
    }

    /**
     * 更新订单状态计数（状态转换时使用）
     */
    public void updateOrderStatusCount(OrderStatus oldStatus, OrderStatus newStatus) {
        decrementOrderStatusCount(oldStatus);
        incrementOrderStatusCount(newStatus);
    }

    /**
     * 获取订单状态统计
     */
    public Map<String, Long> getOrderStatusStatistics() {
        Map<String, Long> stats = new HashMap<>();
        for (OrderStatus status : OrderStatus.values()) {
            String count = jedis.get("order:count:status:" + status.name());
            stats.put(status.name(), count != null ? Long.parseLong(count) : 0L);
        }
        return stats;
    }
}
```

## 控制器层设计

### OrderController扩展

```java
@RestController
@RequestMapping("/api/order")
@Api(tags = "订单管理接口")
@Validated
public class OrderController {

    private static final Logger logger = LoggerFactory.getLogger(OrderController.class);

    @Autowired
    private OrderService orderService;

    // 现有方法保持不变...

    /**
     * 支付订单
     */
    @PostMapping("/{orderId}/pay")
    @ApiOperation("支付订单")
    public ResponseEntity<ApiResponse<OrderStatusUpdateResponse>> payOrder(
            @PathVariable @NotBlank(message = "订单ID不能为空") String orderId) {

        try {
            OrderStatusUpdateResponse response = orderService.payOrder(orderId);
            return ResponseEntity.ok(ApiResponse.success(response, "支付成功"));
        } catch (OrderNotFoundException e) {
            return ResponseEntity.status(404)
                    .body(ApiResponse.error(404, e.getMessage()));
        } catch (InvalidOrderStatusException e) {
            return ResponseEntity.status(400)
                    .body(ApiResponse.error(400, e.getMessage()));
        } catch (Exception e) {
            logger.error("Failed to pay order: {}", orderId, e);
            return ResponseEntity.status(500)
                    .body(ApiResponse.error(500, "支付失败"));
        }
    }

    /**
     * 取消订单
     */
    @PostMapping("/{orderId}/cancel")
    @ApiOperation("取消订单")
    public ResponseEntity<ApiResponse<OrderStatusUpdateResponse>> cancelOrder(
            @PathVariable @NotBlank(message = "订单ID不能为空") String orderId) {

        try {
            OrderStatusUpdateResponse response = orderService.cancelOrder(orderId);
            return ResponseEntity.ok(ApiResponse.success(response, "取消成功"));
        } catch (OrderNotFoundException e) {
            return ResponseEntity.status(404)
                    .body(ApiResponse.error(404, e.getMessage()));
        } catch (InvalidOrderStatusException e) {
            return ResponseEntity.status(400)
                    .body(ApiResponse.error(400, e.getMessage()));
        } catch (Exception e) {
            logger.error("Failed to cancel order: {}", orderId, e);
            return ResponseEntity.status(500)
                    .body(ApiResponse.error(500, "取消失败"));
        }
    }

    /**
     * 完成订单（确认收货）
     */
    @PostMapping("/{orderId}/complete")
    @ApiOperation("完成订单（确认收货）")
    public ResponseEntity<ApiResponse<OrderStatusUpdateResponse>> completeOrder(
            @PathVariable @NotBlank(message = "订单ID不能为空") String orderId) {

        try {
            OrderStatusUpdateResponse response = orderService.completeOrder(orderId);
            return ResponseEntity.ok(ApiResponse.success(response, "确认收货成功"));
        } catch (OrderNotFoundException e) {
            return ResponseEntity.status(404)
                    .body(ApiResponse.error(404, e.getMessage()));
        } catch (InvalidOrderStatusException e) {
            return ResponseEntity.status(400)
                    .body(ApiResponse.error(400, e.getMessage()));
        } catch (Exception e) {
            logger.error("Failed to complete order: {}", orderId, e);
            return ResponseEntity.status(500)
                    .body(ApiResponse.error(500, "确认收货失败"));
        }
    }

    /**
     * 查询订单详情
     */
    @GetMapping("/{orderId}")
    @ApiOperation("查询订单详情")
    public ResponseEntity<ApiResponse<OrderDetailDto>> getOrderDetail(
            @PathVariable @NotBlank(message = "订单ID不能为空") String orderId) {

        try {
            OrderDetailDto orderDetail = orderService.getOrderDetail(orderId);
            return ResponseEntity.ok(ApiResponse.success(orderDetail, "查询成功"));
        } catch (OrderNotFoundException e) {
            return ResponseEntity.status(404)
                    .body(ApiResponse.error(404, e.getMessage()));
        } catch (Exception e) {
            logger.error("Failed to get order detail: {}", orderId, e);
            return ResponseEntity.status(500)
                    .body(ApiResponse.error(500, "查询失败"));
        }
    }
}
```

## 库存管理策略

### 库存操作时机

#### 1. 订单创建时
- **扣减库存**：立即扣减Redis中的库存
- **原子操作**：使用Lua脚本保证扣减原子性
- **失败回滚**：创建失败时自动回滚库存

#### 2. 订单取消时
- **回库库存**：立即增加Redis中的库存
- **原子操作**：使用INCR命令保证回库原子性
- **数据一致**：确保库存数据准确

#### 3. 订单完成时
- **无需操作**：库存已确认扣减，无需变动
- **状态记录**：标记为已销售库存

### 库存数据一致性

#### Redis库存管理
```java
// 扣减库存（原子操作）
public boolean deductStock(String productId, int quantity) {
    // 使用Lua脚本保证原子性
}

// 回库库存（原子操作）- 改名避免与事务回滚混淆
public void restoreStock(String productId, int quantity) {
    // 使用INCR增加库存
}
```

#### 异常处理策略
- **扣减失败**：订单创建失败，回滚已扣减库存
- **回库失败**：记录异常，人工干预处理
- **数据不一致**：通过定时任务检测修复

### Redis订单状态计数器设计（应对高并发统计需求）

#### 设计目标
考虑到将来需要对订单数据进行统计分析，在高并发订单场景下，直接查询HBase会有较大压力。因此引入Redis计数器来缓存订单状态统计数据。

#### 计数器Key设计
```
order:count:total                    # 订单总数
order:count:status:{status}          # 各状态订单数量
order:count:daily:{date}             # 每日订单数
order:count:daily:{date}:{status}    # 每日各状态订单数
```

#### 计数器更新时机
1. **订单创建时**：
   - `INCR order:count:total`
   - `INCR order:count:status:PENDING_PAYMENT`
   - `INCR order:count:daily:{today}`
   - `INCR order:count:daily:{today}:PENDING_PAYMENT`

2. **订单支付时**：
   - `DECR order:count:status:PENDING_PAYMENT`
   - `INCR order:count:status:PAID`
   - `DECR order:count:daily:{today}:PENDING_PAYMENT`
   - `INCR order:count:daily:{today}:PAID`

3. **订单取消时**：
   - `DECR order:count:status:PENDING_PAYMENT`
   - `INCR order:count:status:CANCELLED`
   - `DECR order:count:daily:{today}:PENDING_PAYMENT`
   - `INCR order:count:daily:{today}:CANCELLED`

4. **订单完成时**：
   - `DECR order:count:status:PAID`
   - `INCR order:count:status:COMPLETED`
   - `DECR order:count:daily:{today}:PAID`
   - `INCR order:count:daily:{today}:COMPLETED`

#### 计数器实现
```java
@Service
public class RedisService {

    /**
     * 增加订单状态计数
     */
    public void incrementOrderStatusCount(OrderStatus status) {
        String today = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));

        // 增加状态计数
        jedis.incr("order:count:status:" + status.name());

        // 增加每日状态计数
        jedis.incr("order:count:daily:" + today + ":" + status.name());
    }

    /**
     * 减少订单状态计数
     */
    public void decrementOrderStatusCount(OrderStatus status) {
        String today = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));

        // 减少状态计数
        jedis.decr("order:count:status:" + status.name());

        // 减少每日状态计数
        jedis.decr("order:count:daily:" + today + ":" + status.name());
    }

    /**
     * 获取订单状态统计
     */
    public Map<String, Long> getOrderStatusStatistics() {
        Map<String, Long> stats = new HashMap<>();
        for (OrderStatus status : OrderStatus.values()) {
            String count = jedis.get("order:count:status:" + status.name());
            stats.put(status.name(), count != null ? Long.parseLong(count) : 0L);
        }
        return stats;
    }
}
```

#### 数据一致性保障
- **初始化**：系统启动时从HBase统计初始化计数器
- **定时校准**：每日凌晨从HBase重新统计校准计数器
- **异常恢复**：状态变更失败时回滚计数器
- **监控告警**：计数器异常波动时触发告警

## 异常处理设计

### 业务异常类型

#### OrderNotFoundException
```java
public class OrderNotFoundException extends RuntimeException {
    public OrderNotFoundException(String orderId) {
        super("订单不存在: " + orderId);
    }
}
```

#### InvalidOrderStatusException
```java
public class InvalidOrderStatusException extends RuntimeException {
    public InvalidOrderStatusException(String message) {
        super(message);
    }
}
```

#### StockOperationException
```java
public class StockOperationException extends RuntimeException {
    public StockOperationException(String message) {
        super(message);
    }
}
```

### 全局异常处理器

```java
@RestControllerAdvice
public class OrderExceptionHandler {

    @ExceptionHandler(OrderNotFoundException.class)
    public ResponseEntity<ApiResponse<Void>> handleOrderNotFound(OrderNotFoundException e) {
        return ResponseEntity.status(404)
                .body(ApiResponse.error(404, e.getMessage()));
    }

    @ExceptionHandler(InvalidOrderStatusException.class)
    public ResponseEntity<ApiResponse<Void>> handleInvalidStatus(InvalidOrderStatusException e) {
        return ResponseEntity.status(400)
                .body(ApiResponse.error(400, e.getMessage()));
    }

    @ExceptionHandler(StockOperationException.class)
    public ResponseEntity<ApiResponse<Void>> handleStockOperation(StockOperationException e) {
        return ResponseEntity.status(500)
                .body(ApiResponse.error(500, e.getMessage()));
    }
}
```

## 测试策略

### 单元测试

#### 1. 状态转换测试
```java
@SpringBootTest
public class OrderStatusTest {

    @Test
    public void testOrderStatusTransitions() {
        // 测试状态转换规则
        assertTrue(OrderStatus.PENDING_PAYMENT.canTransitionTo(OrderStatus.PAID));
        assertTrue(OrderStatus.PENDING_PAYMENT.canTransitionTo(OrderStatus.CANCELLED));
        assertTrue(OrderStatus.PAID.canTransitionTo(OrderStatus.COMPLETED));

        assertFalse(OrderStatus.COMPLETED.canTransitionTo(OrderStatus.PAID));
        assertFalse(OrderStatus.CANCELLED.canTransitionTo(OrderStatus.PAID));
    }
}
```

#### 2. 服务层测试
```java
@SpringBootTest
public class OrderServiceTest {

    @Autowired
    private OrderService orderService;

    @Test
    public void testPayOrder() {
        // 测试支付功能
    }

    @Test
    public void testCancelOrder() {
        // 测试取消功能和库存回库
    }

    @Test
    public void testCompleteOrder() {
        // 测试完成功能
    }

    @Test
    public void testInvalidStatusTransition() {
        // 测试无效状态转换
    }
}
```

### 集成测试

#### 1. 订单状态流转测试
- 创建订单 → 支付订单 → 完成订单
- 创建订单 → 取消订单
- 验证各种异常情况

#### 2. 库存管理测试
- 订单创建时的库存扣减
- 订单取消时的库存回库
- 并发操作下的库存一致性

#### 3. 数据一致性测试
- Redis和HBase数据同步
- 异常情况下的数据回滚
- 状态时间戳更新正确性

### 性能测试

#### 1. 并发状态操作测试
- 模拟多用户并发支付订单
- 验证状态转换的并发安全性

#### 2. 库存操作性能测试
- 测试高并发下的库存扣减和回库
- 验证Redis原子操作的性能

## 实施计划

### 第一阶段：数据模型和基础结构（2天）

#### Day 1：状态枚举和模型更新
- [ ] 修改OrderStatus枚举，添加CANCELLED状态
- [ ] 更新Order模型，添加时间戳字段
- [ ] 实现状态转换验证方法
- [ ] 创建新的DTO类和异常类

#### Day 2：Redis服务扩展
- [ ] 在RedisService中添加rollbackStock方法
- [ ] 实现库存回库逻辑
- [ ] 测试库存操作的原子性
- [ ] 更新相关测试用例

### 第二阶段：服务层实现（3天）

#### Day 3：OrderHBaseService扩展
- [ ] 实现updateOrder方法（状态更新）
- [ ] 实现getOrderById方法（详情查询）
- [ ] 测试HBase更新操作
- [ ] 验证数据序列化正确性

#### Day 4：OrderService状态管理
- [ ] 实现payOrder方法
- [ ] 实现cancelOrder方法（含库存回库）
- [ ] 实现completeOrder方法
- [ ] 实现getOrderDetail方法

#### Day 5：OrderService完善
- [ ] 添加状态转换验证
- [ ] 实现异常处理逻辑
- [ ] 添加事务管理
- [ ] 完善日志记录

### 第三阶段：控制器层实现（2天）

#### Day 6：OrderController扩展
- [ ] 实现支付订单接口
- [ ] 实现取消订单接口
- [ ] 实现完成订单接口
- [ ] 实现查询订单详情接口

#### Day 7：异常处理和文档
- [ ] 完善全局异常处理
- [ ] 添加Swagger API文档
- [ ] 更新[002]API接口文档
- [ ] 更新[106]订单功能开发方案文档

### 第四阶段：测试和优化（3天）

#### Day 8：单元测试
- [ ] 编写状态管理单元测试
- [ ] 编写服务层单元测试
- [ ] 编写控制器层测试
- [ ] 编写异常处理测试

#### Day 9：集成测试
- [ ] 进行订单状态流转测试
- [ ] 测试库存管理功能
- [ ] 验证数据一致性
- [ ] 测试并发安全性

#### Day 10：系统优化
- [ ] 性能测试和优化
- [ ] 部署到测试环境
- [ ] 验收测试
- [ ] 文档完善

### 总计时间：10天

### 风险控制

#### 1. 技术风险
- **状态转换复杂性**：通过状态机模式简化转换逻辑
- **库存数据一致性**：通过原子操作和事务保证一致性
- **HBase更新性能**：通过批量更新和索引优化

#### 2. 业务风险
- **状态流转错误**：通过严格的状态验证防止非法转换
- **库存计算错误**：通过单元测试验证计算逻辑
- **并发操作冲突**：通过乐观锁和重试机制处理

#### 3. 实施风险
- **需求理解偏差**：与用户确认状态流转规则
- **测试不充分**：编写完整的测试用例覆盖所有场景
- **上线影响**：分阶段上线，逐步放量

### 验收标准

#### 1. 功能验收
- [ ] 订单支付功能正常
- [ ] 订单取消功能正常（含库存回库）
- [ ] 订单完成功能正常
- [ ] 订单详情查询正常
- [ ] 状态流转规则正确

#### 2. 性能验收
- [ ] 状态操作响应时间<200ms
- [ ] 支持100+并发状态操作
- [ ] 库存操作原子性100%
- [ ] 数据一致性>99.9%

#### 3. 质量验收
- [ ] 单元测试覆盖率>85%
- [ ] 集成测试通过率100%
- [ ] 代码审查通过
- [ ] 文档完整准确

---

**文档状态**：完成
**审核状态**：待审核
**版本控制**：
- v1.0 (2026-01-07)：完成订单状态管理（支付、取消、完成）详细开发方案
- v1.1 (2026-01-08)：新增Redis订单状态计数器设计，优化库存回库方法命名，完善服务层实现细节

## 改进说明

### 相比原方案的主要改进

1. **新增Redis订单状态计数器**
   - 应对高并发统计需求，避免频繁查询HBase
   - 支持实时统计各状态订单数量
   - 支持每日订单统计
   - 提供数据一致性保障机制

2. **优化方法命名**
   - 将`rollbackStock`改为`restoreStock`，避免与事务回滚概念混淆
   - 更清晰地表达库存归还的业务语义

3. **完善服务层实现**
   - 在状态变更时同步更新Redis计数器
   - 详细的日志记录便于问题排查
   - 完整的异常处理和回滚机制

4. **增强OrderHBaseService**
   - 提供完整的订单查询和更新实现
   - 支持按订单ID精确查询
   - 正确处理RowKey生成和解析

5. **数据一致性保障**
   - 计数器初始化和定时校准机制
   - 异常情况下的计数器回滚
   - 监控告警机制
