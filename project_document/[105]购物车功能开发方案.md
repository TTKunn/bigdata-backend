# [101] 购物车功能开发方案

## 文档信息

| 文档编号 | [101] |
|----------|-------|
| 文档名称 | 购物车功能开发方案 |
| 版本号 | 1.0 |
| 创建日期 | 2026-01-07 |
| 作者 | 系统架构师 |
| 项目名称 | 大数据商城后端系统 |
| 背景 | 基于需求分析文档和现有代码结构，制定购物车功能详细开发方案 |

## 目录

1. [项目背景](#项目背景)
2. [功能需求分析](#功能需求分析)
3. [技术方案设计](#技术方案设计)
4. [API接口设计](#API接口设计)
5. [数据结构设计](#数据结构设计)
6. [服务层设计](#服务层设计)
7. [控制器层设计](#控制器层设计)
8. [异常处理设计](#异常处理设计)
9. [性能优化策略](#性能优化策略)
10. [测试策略](#测试策略)
11. [实施计划](#实施计划)

## 项目背景

### 当前系统状态

根据现有代码分析，系统已实现：
- **商品管理**：完整的商品创建、查询、库存管理功能
- **Redis缓存**：商品信息缓存、库存缓存、原子扣减操作
- **HBase存储**：商品数据持久化存储
- **API框架**：统一的API响应格式、参数校验、异常处理

### 需求来源

根据`[000]需求分析文档.md`中购物车管理模块需求：
1. **功能需求**：添加商品、修改数量、删除商品、清空购物车、查询购物车
2. **技术实现**：基于Redis Hash结构存储
3. **数据结构**：Key为`cart:{userId}`，Field为`{productId}`
4. **性能要求**：支持高并发访问，响应时间<100ms

### 项目简化说明

本项目为学习项目，采用以下简化策略：
- **单一用户模式**：使用固定默认用户ID `"000000000001"`，简化用户管理
- **单环境部署**：不区分dev/prod环境，简化配置管理
- **库存检查策略**：购物车添加时仅检查库存是否充足，不实际扣减库存；库存扣减在订单创建时进行

### 开发目标

实现完整的购物车管理功能，支持电商场景下的购物车操作，满足高并发、高性能的要求。

## 功能需求分析

### 核心功能点

#### 1. 添加商品到购物车
- **功能描述**：将商品添加到用户购物车
- **业务规则**：
  - 检查商品是否存在
  - 检查库存是否充足（不扣减库存，仅校验）
  - 如果商品已在购物车中，增加数量
  - 如果商品不在购物车中，新增商品项
- **输入参数**：productId, quantity
- **输出结果**：操作成功状态

#### 2. 修改商品数量
- **功能描述**：修改购物车中商品的数量
- **业务规则**：
  - 检查商品是否存在于购物车
  - 验证新数量的合理性
  - 检查库存是否充足（不扣减库存，仅校验）
- **输入参数**：productId, quantity
- **输出结果**：修改后的商品信息

#### 3. 删除购物车商品
- **功能描述**：从购物车中移除指定商品
- **业务规则**：
  - 支持单个商品删除
  - 支持批量删除
- **输入参数**：productIds[]
- **输出结果**：删除成功状态

#### 4. 清空购物车
- **功能描述**：清空用户的所有购物车商品
- **业务规则**：直接删除整个购物车Hash
- **输入参数**：无（使用默认用户）
- **输出结果**：清空成功状态

#### 5. 查询购物车
- **功能描述**：获取用户的购物车商品列表
- **业务规则**：
  - 返回所有购物车商品信息
  - 包含商品基本信息、数量、添加时间、选中状态
- **输入参数**：无（使用默认用户）
- **输出结果**：购物车商品列表

### 扩展功能点

#### 6. 购物车商品选中/取消选中
- **功能描述**：设置商品的选中状态，用于结算时选择部分商品
- **输入参数**：productId, selected
- **输出结果**：设置成功状态

#### 7. 批量修改商品选中状态
- **功能描述**：批量设置多个商品的选中状态
- **输入参数**：productSelections[{productId, selected}]
- **输出结果**：批量设置结果

#### 8. 获取购物车统计信息
- **功能描述**：获取购物车的商品总数、总金额等统计信息
- **输入参数**：无（使用默认用户）
- **输出结果**：购物车统计信息

## 技术方案设计

### 整体架构

```
Controller Layer (CartController)
        ↓
Service Layer (CartService)
        ↓
├── RedisService (购物车数据操作)
├── ProductService (商品信息查询)
└── Validation (业务规则校验)
```

### 技术选型

#### 数据存储
- **主存储**：Redis Hash
- **默认用户**：固定使用用户ID `"000000000001"`
- **数据结构**：
  ```redis
  Key: cart:000000000001
  Field: {productId}  # 直接使用商品ID，如 "00010001"
  Value: JSON字符串 {"quantity":数量, "addTime":时间戳, "selected":布尔值}
  ```

#### 缓存策略
- **过期时间**：7天（604800秒）
- **内存管理**：定期清理过期购物车
- **数据一致性**：购物车数据仅存储在Redis，不需要与HBase同步

#### 并发控制
- **原子操作**：通过Redis的原子操作保证数据一致性
- **库存检查**：添加商品时实时检查Redis库存，仅校验不扣减
- **库存扣减**：实际库存扣减在订单创建时进行

### 性能目标

#### 响应时间
- **添加商品**：< 50ms
- **查询购物车**：< 100ms
- **修改数量**：< 30ms
- **删除商品**：< 20ms

#### 并发处理
- **单用户并发**：支持10+并发操作
- **多用户并发**：支持100+ TPS
- **库存检查并发**：支持100+并发库存检查

## API接口设计

### 接口路径规划

```
POST   /api/cart/add          # 添加商品到购物车
PUT    /api/cart/update       # 修改商品数量
DELETE /api/cart/remove       # 删除购物车商品
DELETE /api/cart/clear        # 清空购物车
GET    /api/cart              # 查询购物车
PUT    /api/cart/select       # 设置商品选中状态
PUT    /api/cart/select/batch # 批量设置选中状态
GET    /api/cart/summary      # 获取购物车统计信息
```

### 接口详细设计

#### 1. 添加商品到购物车

**接口路径**：`POST /api/cart/add`

**请求参数**：
```json
{
  "productId": "00010001",
  "quantity": 2
}
```

**响应结果**：
```json
{
  "code": 200,
  "message": "添加成功",
  "timestamp": "2026-01-07T10:30:00Z",
  "data": {
    "productId": "00010001",
    "quantity": 2,
    "addTime": "2026-01-07T10:30:00Z"
  }
}
```

#### 2. 修改商品数量

**接口路径**：`PUT /api/cart/update`

**请求参数**：
```json
{
  "productId": "00010001",
  "quantity": 3
}
```

#### 3. 删除购物车商品

**接口路径**：`DELETE /api/cart/remove`

**请求参数**：
```json
{
  "productIds": ["00010001", "00010002"]
}
```

#### 4. 查询购物车

**接口路径**：`GET /api/cart`

**响应结果**：
```json
{
  "code": 200,
  "message": "查询成功",
  "timestamp": "2026-01-07T10:30:00Z",
  "data": {
    "userId": "000000000001",
    "items": [
      {
        "productId": "00010001",
        "productName": "华为Mate60 Pro",
        "price": 6999.00,
        "quantity": 2,
        "addTime": "2026-01-07T10:25:00Z",
        "selected": true
      },
      {
        "productId": "00010002",
        "productName": "iPhone 15 Pro",
        "price": 8999.00,
        "quantity": 1,
        "addTime": "2026-01-07T10:28:00Z",
        "selected": false
      }
    ],
    "totalQuantity": 3,
    "totalAmount": 22997.00
  }
}
```

#### 5. 清空购物车

**接口路径**：`DELETE /api/cart/clear`

**请求参数**：无

#### 6. 设置商品选中状态

**接口路径**：`PUT /api/cart/select`

**请求参数**：
```json
{
  "productId": "00010001",
  "selected": true
}
```

#### 7. 批量设置选中状态

**接口路径**：`PUT /api/cart/select/batch`

**请求参数**：
```json
{
  "selections": [
    {"productId": "00010001", "selected": true},
    {"productId": "00010002", "selected": false}
  ]
}
```

#### 8. 获取购物车统计信息

**接口路径**：`GET /api/cart/summary`

**响应结果**：
```json
{
  "code": 200,
  "message": "查询成功",
  "timestamp": "2026-01-07T10:30:00Z",
  "data": {
    "totalItems": 3,
    "totalQuantity": 5,
    "totalAmount": 34995.00,
    "selectedItems": 2,
    "selectedQuantity": 3,
    "selectedAmount": 22997.00
  }
}
```

## 数据结构设计

### 请求DTO设计

#### CartAddRequest
```java
public class CartAddRequest {
    @NotBlank(message = "商品ID不能为空")
    private String productId;

    @Min(value = 1, message = "商品数量必须大于0")
    private Integer quantity = 1;
}
```

#### CartUpdateRequest
```java
public class CartUpdateRequest {
    @NotBlank(message = "商品ID不能为空")
    private String productId;

    @Min(value = 1, message = "商品数量必须大于0")
    private Integer quantity;
}
```

#### CartRemoveRequest
```java
public class CartRemoveRequest {
    @NotEmpty(message = "商品ID列表不能为空")
    private List<String> productIds;
}
```

#### CartSelectRequest
```java
public class CartSelectRequest {
    @NotBlank(message = "商品ID不能为空")
    private String productId;

    @NotNull(message = "选中状态不能为空")
    private Boolean selected;
}
```

#### CartBatchSelectRequest
```java
public class CartBatchSelectRequest {
    @NotEmpty(message = "选中设置列表不能为空")
    private List<ProductSelection> selections;

    public static class ProductSelection {
        @NotBlank(message = "商品ID不能为空")
        private String productId;

        @NotNull(message = "选中状态不能为空")
        private Boolean selected;
    }
}
```

### 模型类设计

#### CartItem（内部使用）
```java
public class CartItem {
    private String productId;      // 商品ID
    private Integer quantity;       // 商品数量
    private Long addTime;          // 添加时间（时间戳）
    private Boolean selected;       // 是否选中
}
```

### 响应DTO设计

#### CartItemDto
```java
public class CartItemDto {
    private String productId;
    private String productName;
    private String category;
    private String brand;
    private BigDecimal price;
    private Integer quantity;
    private LocalDateTime addTime;
    private Boolean selected;
}
```

#### CartResponse
```java
public class CartResponse {
    private String userId;
    private List<CartItemDto> items;
    private Integer totalQuantity;
    private BigDecimal totalAmount;
}
```

#### CartSummaryResponse
```java
public class CartSummaryResponse {
    private Integer totalItems;      // 商品种类数
    private Integer totalQuantity;   // 商品总数量
    private BigDecimal totalAmount;  // 商品总金额
    private Integer selectedItems;   // 已选中商品种类数
    private Integer selectedQuantity; // 已选中商品总数量
    private BigDecimal selectedAmount; // 已选中商品总金额
}
```

## 服务层设计

### CartService 接口设计

```java
public interface CartService {
    // 添加商品到购物车（使用默认用户）
    void addItem(String productId, Integer quantity);

    // 更新商品数量
    void updateItemQuantity(String productId, Integer quantity);

    // 删除购物车商品
    void removeItems(List<String> productIds);

    // 清空购物车
    void clearCart();

    // 查询购物车
    CartResponse getCart();

    // 设置商品选中状态
    void setItemSelected(String productId, Boolean selected);

    // 批量设置选中状态
    void batchSetSelected(List<CartBatchSelectRequest.ProductSelection> selections);

    // 获取购物车统计信息
    CartSummaryResponse getCartSummary();
}
```

### CartServiceImpl 实现设计

```java
@Service
public class CartServiceImpl implements CartService {

    @Autowired
    private RedisService redisService;

    @Autowired
    private ProductService productService;

    private static final String DEFAULT_USER_ID = "000000000001";
    private static final String CART_KEY_PREFIX = "cart:";
    private static final int CART_EXPIRE_SECONDS = 604800; // 7天

    /**
     * 添加商品到购物车
     */
    @Override
    public void addItem(String productId, Integer quantity) {
        // 1. 验证商品存在性
        Product product = productService.getProduct(productId);
        if (product == null) {
            throw new IllegalArgumentException("商品不存在");
        }

        // 2. 检查库存（仅校验，不扣减）
        Integer stock = redisService.getStock(productId);
        if (stock == null || stock < quantity) {
            throw new IllegalArgumentException("商品库存不足");
        }

        // 3. 获取或创建购物车项
        String cartKey = CART_KEY_PREFIX + DEFAULT_USER_ID;
        String field = productId;  // 直接使用商品ID作为field

        String existingItem = redisService.hget(cartKey, field);
        CartItem cartItem;

        if (existingItem != null) {
            // 商品已存在，增加数量
            cartItem = parseCartItem(existingItem);
            int newQuantity = cartItem.getQuantity() + quantity;

            // 检查新数量是否超过库存
            if (stock < newQuantity) {
                throw new IllegalArgumentException("商品库存不足");
            }
            cartItem.setQuantity(newQuantity);
        } else {
            // 新增商品
            cartItem = new CartItem();
            cartItem.setProductId(productId);
            cartItem.setQuantity(quantity);
            cartItem.setAddTime(System.currentTimeMillis());
            cartItem.setSelected(true); // 默认选中
        }

        // 4. 保存到Redis
        redisService.hset(cartKey, field, serializeCartItem(cartItem));
        redisService.expire(cartKey, CART_EXPIRE_SECONDS);
    }

    /**
     * 序列化购物车项
     */
    private String serializeCartItem(CartItem item) {
        Gson gson = new Gson();
        return gson.toJson(item);
    }

    /**
     * 反序列化购物车项
     */
    private CartItem parseCartItem(String json) {
        Gson gson = new Gson();
        return gson.fromJson(json, CartItem.class);
    }

    // 其他方法实现...
}
```

### Redis操作扩展

在RedisService中添加购物车相关方法：

```java
// 购物车相关方法
public void hset(String key, String field, String value);
public String hget(String key, String field);
public Map<String, String> hgetAll(String key);
public void hdel(String key, String... fields);
public void del(String key);
public void expire(String key, int seconds);
```

## 控制器层设计

### CartController 设计

```java
@RestController
@RequestMapping("/api/cart")
@Api(tags = "购物车管理接口")
@Validated
public class CartController {

    private static final Logger logger = LoggerFactory.getLogger(CartController.class);

    @Autowired
    private CartService cartService;

    /**
     * 添加商品到购物车
     */
    @PostMapping("/add")
    @ApiOperation("添加商品到购物车")
    public ResponseEntity<ApiResponse<Void>> addItem(
            @Valid @RequestBody CartAddRequest request) {

        try {
            cartService.addItem(request.getProductId(), request.getQuantity());
            return ResponseEntity.ok(ApiResponse.success(null, "添加成功"));
        } catch (IllegalArgumentException e) {
            logger.warn("Failed to add item to cart: {}", e.getMessage());
            return ResponseEntity.badRequest().body(ApiResponse.error(400, e.getMessage()));
        } catch (Exception e) {
            logger.error("Failed to add item to cart", e);
            return ResponseEntity.status(500).body(ApiResponse.error(500, "添加失败"));
        }
    }

    /**
     * 查询购物车
     */
    @GetMapping
    @ApiOperation("查询购物车")
    public ResponseEntity<ApiResponse<CartResponse>> getCart() {

        try {
            CartResponse cart = cartService.getCart();
            return ResponseEntity.ok(ApiResponse.success(cart, "查询成功"));
        } catch (Exception e) {
            logger.error("Failed to get cart", e);
            return ResponseEntity.status(500).body(ApiResponse.error(500, "查询失败"));
        }
    }

    // 其他接口实现...
}
```

## 异常处理设计

### 业务异常类型

```java
public class CartException extends RuntimeException {
    private int code;

    public CartException(int code, String message) {
        super(message);
        this.code = code;
    }

    public CartException(int code, String message, Throwable cause) {
        super(message, cause);
        this.code = code;
    }
}

public class ProductNotFoundException extends CartException {
    public ProductNotFoundException(String productId) {
        super(404, "商品不存在: " + productId);
    }
}

public class InsufficientStockException extends CartException {
    public InsufficientStockException(String productId, int requested, int available) {
        super(409, String.format("商品库存不足，商品ID: %s，请求数量: %d，可用库存: %d",
                productId, requested, available));
    }
}

public class CartItemNotFoundException extends CartException {
    public CartItemNotFoundException(String productId) {
        super(404, "购物车中不存在该商品: " + productId);
    }
}
```

### 全局异常处理

```java
@RestControllerAdvice
public class CartExceptionHandler {

    @ExceptionHandler(CartException.class)
    public ResponseEntity<ApiResponse<Void>> handleCartException(CartException e) {
        return ResponseEntity.status(e.code >= 500 ? 500 : e.code)
                .body(ApiResponse.error(e.code, e.getMessage()));
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiResponse<Void>> handleIllegalArgument(IllegalArgumentException e) {
        return ResponseEntity.badRequest()
                .body(ApiResponse.error(400, e.getMessage()));
    }
}
```

## 性能优化策略

### 1. Redis连接池优化
- **连接池配置**：最大连接数20，最大空闲连接10，最小空闲连接5
- **连接测试**：获取连接时测试可用性

### 2. 数据序列化优化
- **JSON序列化**：使用Gson进行快速序列化
- **数据压缩**：对于大数据量的购物车考虑压缩存储

### 3. 缓存策略优化
- **热点数据缓存**：商品基本信息单独缓存
- **批量操作**：支持批量添加、批量删除
- **懒加载**：查询时按需加载商品详细信息

### 4. 并发控制优化
- **分布式锁**：对于关键操作使用Redis分布式锁
- **乐观锁**：通过版本号控制并发修改
- **队列处理**：高并发场景下使用队列异步处理

### 5. 监控和告警
- **性能监控**：记录API响应时间
- **错误监控**：监控异常发生率
- **容量监控**：监控Redis内存使用率

## 测试策略

### 功能测试

使用ApiFox或Postman进行接口测试，验证各个功能点是否正常工作。

### 测试说明

根据项目规范，非必要不编写测试文件。如确实需要测试文件，应放入 `test/` 目录，并在验证通过后删除临时测试文件。

## 实施计划

### TodoList

#### 阶段一：基础数据结构和DTO

- [ ] 创建CartItem模型类（内部使用）
- [ ] 创建CartAddRequest请求DTO
- [ ] 创建CartUpdateRequest请求DTO
- [ ] 创建CartRemoveRequest请求DTO
- [ ] 创建CartItemDto响应DTO
- [ ] 创建CartResponse响应DTO

#### 阶段二：Redis服务扩展

- [ ] 在RedisService中添加hset方法
- [ ] 在RedisService中添加hget方法
- [ ] 在RedisService中添加hgetAll方法
- [ ] 在RedisService中添加hdel方法
- [ ] 在RedisService中添加del方法
- [ ] 在RedisService中添加expire方法

#### 阶段三：购物车服务层实现

- [ ] 创建CartService接口
- [ ] 创建CartServiceImpl实现类
- [ ] 实现addItem方法（添加商品到购物车）
- [ ] 实现getCart方法（查询购物车）
- [ ] 实现序列化和反序列化方法

#### 阶段四：控制器层实现

- [ ] 创建CartController控制器
- [ ] 实现添加商品接口（POST /api/cart/add）
- [ ] 实现查询购物车接口（GET /api/cart）
- [ ] 添加Swagger API文档注解

#### 阶段五：功能测试和验证

- [ ] 测试添加商品到购物车功能
- [ ] 测试查询购物车功能
- [ ] 测试商品已存在时增加数量
- [ ] 测试库存不足的异常处理
- [ ] 测试商品不存在的异常处理
- [ ] 更新API接口文档

#### 阶段六：扩展功能（后续实现）

- [ ] 实现修改商品数量功能
- [ ] 实现删除购物车商品功能
- [ ] 实现清空购物车功能
- [ ] 实现商品选中状态管理
- [ ] 实现购物车统计信息功能

### 风险控制

#### 1. 技术风险
- **Redis连接问题**：提前验证Redis集群配置
- **并发竞争问题**：使用Redis原子操作保证一致性
- **内存溢出风险**：设置合理的过期时间和内存限制

#### 2. 业务风险
- **数据一致性**：通过业务规则校验保证数据正确性
- **用户体验**：保证API响应时间符合要求

### 验收标准

#### 1. 功能验收
- [ ] 添加商品到购物车接口正常工作
- [ ] 查询购物车接口正常工作
- [ ] 业务规则正确实现（商品存在性、库存检查）
- [ ] 异常情况正确处理

#### 2. 性能验收
- [ ] API响应时间符合要求（<100ms）
- [ ] Redis操作正常
- [ ] 系统稳定性良好

#### 3. 质量验收
- [ ] 代码符合项目规范
- [ ] 日志记录完整
- [ ] API文档更新完整

---

**文档状态**：已完成
**审核状态**：已审核
**版本控制**：
- v1.0 (2026-01-07)：完成购物车功能详细开发方案设计
- v1.1 (2026-01-07)：根据项目简化要求调整方案
  - 移除dev环境限制，统一使用单一环境
  - 简化用户管理，使用固定默认用户ID
  - 优化Redis数据结构，field直接使用商品ID
  - 明确库存检查策略（仅校验不扣减）
  - 添加CartItem模型类定义
  - 移除时间估算，保留具体实施步骤
  - 简化测试策略说明
